/**
 * Оконный сервер. Отвечает за композицию и вывод на экран слоёв рабочих пространств, окон и курсора.
 * Также в его обязанности входит отправка некоторых событий в процессы.
 *
 * Каждый процесс может иметь по одному подключению к серверу.
 * Процесс, успевший обозначить себя (своё подключение) универсальным владельцем, имеет права администратора сервера.
 * Администратор владеет всеми окнами и курсорами наравне с процессами, их создавшими.
 *
 * _Этот класс является служебным и не предназначен для использования сторонними приложениями._
 */
// noinspection JSAnnotator
return $CFShared[_title] ?? class CGSWindowServer extends CFObject {
	static __shared;

	static get shared() {
		if(!this.__shared) {
			new this();
		}

		return this.__shared;
	}

	__connections = new CFArray();
	__workspaces = new CFArray();
	__windows = new CFArray();
	__cursors = new CFArray();
	__cursor = new CFObject({
		origin: new CGPoint(),
		obscured: false,
		scale: 1
	});
	__layer = new CGLayer({ width: CGScreen.size.width, height: CGScreen.size.height });

	constructor() {
		super();
		if(!this.constructor.__shared) {
			this.constructor.__shared = this;
		} else {
			console.error(0); return;
		}

		CFEvent.addHandler('workspaceListChanged', (a) => {
			if(a.event === 'added' && !this.__workspaces.contains({ where: v => v.current })) {
				this.setCurrentWorkspace(CGSConnection.shared, a.value);
			}
		});
		CFEvent.addHandler('workspaceChanged', (a) => {
			if(a.event === 'current') {
				this.__draw();
			}
		});

		let x, y;

		CFEvent.addHandler('mouseChanged', (a) => {
			if(a.event === 'mousemove' && (x !== a.value.x || y !== a.value.y)) {
				x = a.value.x;
				y = a.value.y;

				this.setCursorOrigin(a.value.x, a.value.y);
			}
		});

		this.setConnectionUniversalOwner(CGSConnection.shared, CGSConnection.shared, true);
		this.createWorkspace(CGSConnection.shared);
		this.createCursor(CGSConnection.shared);
	}

	__draw() {
		let layer = this.__layer,
			workspaces = this.__workspaces,
			currentPosition = 0,
			layers = []

		layer.backgroundColor = CGColor('75', '75', '75');
		for(let v of workspaces) {
			if(!v.current) {
				v.layer.hidden = true;
			} else {
				v.layer.hidden = false;
				currentPosition = workspaces.firstIndex({ of: v });
			}
			layers.push(v.layer);
		}
		for(let v of layers) {
			v.x = v.width*layers.indexOf(v)-v.width*currentPosition;
		}

		if(!this.__cursors.empty) {
			let cursor = this.__cursors.first({ where: v => v.current }),
				cursorLayer = cursor.layers[0]

			cursorLayer.x = this.__cursor.origin.x-cursor.hotspot.x;
			cursorLayer.y = this.__cursor.origin.y-cursor.hotspot.y;

			layers.push(cursorLayer);
		}
		layer.sublayers = layers;

		_call('fbWrite', this.__layer.draw().__internalLayer);
	}

	createConnection(processInfo) {
		if(!Object.isObject(processInfo) || !Object.isMemberOf(processInfo, CFProcessInfo))		throw new TypeError(0);
		if(this.__connections.contains({ where: v => v.processID === processInfo.identifier }))	throw new RangeError(1);

		let ID = new Number(!this.__connections.empty ? Math.max(...this.__connections.map(v => v.ID))+1 : 1);	// Упаковка примитива в объект обезопасивает сравнения, передать в качестве аргумента чужой ID просто так не получится

		this.__connections.add({
			ID: ID,
			processID: processInfo.identifier,
			universalOwner: false
		});
		CFEvent.dispatch(CFProcessInfo.shared.identifier, 'connectionsListChanged', { event: 'added', value: ID });

		return ID;
	}

	getConnectionID(connectionID, processID) {
		if(!Object.isKindOf(connectionID, Number))													throw new TypeError(0);
		if(typeof processID !== 'number')															throw new TypeError(1);
		if(!this.__connections.contains({ where: v => v.ID === connectionID && v.universalOwner }))	throw new RangeError(2);

		return this.__connections.first({ where: v => v.processID === processID })?.ID;
	}

	getConnectionProcessID(connectionID, connectionID_) {
		if(!Object.isKindOf(connectionID, Number))													throw new TypeError(0);
		if(!Object.isKindOf(connectionID_, Number))													throw new TypeError(1);
		if(!this.__connections.contains({ where: v => v.ID === connectionID && v.universalOwner }))	throw new RangeError(2);

		return this.__connections.first({ where: v => v.ID === connectionID_ })?.processID;
	}

	getConnectionUniversalOwner(connectionID, connectionID_) {
		if(!Object.isKindOf(connectionID, Number))													throw new TypeError(0);
		if(!Object.isKindOf(connectionID_, Number))													throw new TypeError(1);
		if(!this.__connections.contains({ where: v => v.ID === connectionID && v.universalOwner }))	throw new RangeError(2);

		return this.__connections.first({ where: v => v.ID === connectionID_ })?.universalOwner;
	}

	setConnectionUniversalOwner(connectionID, connectionID_, value) {
		if(!Object.isKindOf(connectionID, Number))													throw new TypeError(0);
		if(!Object.isKindOf(connectionID_, Number))													throw new TypeError(1);
		if(typeof value !== 'boolean')																throw new TypeError(2);
		if(
			this.__connections.contains({ where: v => v.universalOwner }) &&
			this.__connections.contains({ where: v => v.ID === connectionID && !v.universalOwner })
		)																							throw new RangeError(3);

		this.__connections.first({ where: v => v.ID === connectionID_ })?.universalOwner = value;
	}

	destroyConnection(connectionID, connectionID_) {
		if(!Object.isKindOf(connectionID, Number))														throw new TypeError(0);
		if(!Object.isKindOf(connectionID_, Number))														throw new TypeError(1);
		if(
			connectionID !== connectionID_ &&
			!this.__connections.contains({ where: v => v.ID === connectionID && v.universalOwner })
		)																								throw new RangeError(2);

		this.__connections.removeAll({ where: v => v.ID === connectionID_ });
		CFEvent.dispatch(CFProcessInfo.shared.identifier, 'connectionsListChanged', { event: 'removed', value: connectionID_ });
	}

	createWorkspace(connectionID) {
		if(!Object.isKindOf(connectionID, Number))													throw new TypeError(0);
		if(!this.__connections.contains({ where: v => v.ID === connectionID && v.universalOwner }))	throw new RangeError(1);

		let ID = !this.__workspaces.empty ? Math.max(...this.__workspaces.map(v => v.ID))+1 : 1;

		this.__workspaces.add({
			ID: ID,
			current: false,
			layer: new CGLayer({ width: this.__layer.width, height: this.__layer.height })
		});
		CFEvent.dispatch(CFProcessInfo.shared.identifier, 'workspaceListChanged', { event: 'added', value: ID });

		return ID;
	}

	getCurrentWorkspace() {
		return this.__workspaces.first({ where: v => v.current })?.ID;
	}

	setCurrentWorkspace(connectionID, workspaceID) {
		if(!Object.isKindOf(connectionID, Number))													throw new TypeError(0);
		if(typeof workspaceID !== 'number')															throw new TypeError(1);
		if(!this.__connections.contains({ where: v => v.ID === connectionID && v.universalOwner }))	throw new RangeError(2);
		if(!this.__workspaces.contains({ where: v => v.ID === workspaceID }))						throw new RangeError(3);
		if(this.__workspaces.contains({ where: v => v.ID === workspaceID && v.current }))			return;

		for(let v of this.__workspaces) {
			v.current = v.ID === workspaceID;
		}
		CFEvent.dispatch(CFProcessInfo.shared.identifier, 'workspaceChanged', { event: 'current', value: workspaceID });
	}

	destroyWorkspace(connectionID, workspaceID) {
		if(!Object.isKindOf(connectionID, Number))													throw new TypeError(0);
		if(typeof workspaceID !== 'number')															throw new TypeError(1);
		if(!this.__connections.contains({ where: v => v.ID === connectionID && v.universalOwner }))	throw new RangeError(2);
		if(!this.__workspaces.contains({ where: v => v.ID === workspaceID }))						throw new RangeError(3);

		this.__workspaces.removeAll({ where: v => v.ID === workspaceID });
		CFEvent.dispatch(CFProcessInfo.shared.identifier, 'workspaceListChanged', { event: 'removed', value: workspaceID });
	}

	createWindow(connectionID, workspaceID, x, y, width, height) {
		if(!Object.isKindOf(connectionID, Number))									throw new TypeError(0);
		if(!this.__connections.contains({ where: v => v.ID === connectionID }))		throw new RangeError(1);
		if(workspaceID) {
			if(typeof workspaceID !== 'number')										throw new TypeError(2);
			if(!this.__workspaces.contains({ where: v => v.ID === workspaceID }))	throw new RangeError(3);
		}

		let window = {
			ID: !this.__windows.empty ? Math.max(...this.__windows.map(v => v.ID))+1 : 1,
			connectionID: connectionID,
			workspaceID: workspaceID ?? this.getCurrentWorkspace(),
			layer: new CGLayer({ x: x, y: y, width: width, height: height })
		}

		window.layer.context.drawRectangle(CGColor(0, 0, 0), 0, 0, width, height);

		this.__windows.add(window);
		CFEvent.dispatch(CFProcessInfo.shared.identifier, 'windowsListChanged', { event: 'added', value: window.ID });

		return window.ID;
	}

	getWindowWorkspace() {}

	getWindowOrigin() {}

	getWindowFrame() {}

	getWindowLevel() {}

	getWindowDepth() {}

	getWindowContext() {}

	setWindowWorkspace() {}

	setWindowOrigin() {}

	setWindowFrame() {}

	setWindowLevel() {}

	setWindowDepth() {}

	destroyWindow() {}

	createCursor(connectionID, layers = new CFArray(), hotspot = new CGPoint(), current = false, global = false, delay = 33.3) {
		if(!Object.isKindOf(connectionID, Number))								throw new TypeError(0);
		if(!Object.isKindOf(layers, CFArray))								throw new TypeError(1);
		if(!Object.isKindOf(hotspot, CGPoint))									throw new TypeError(2);
		if(typeof current !== 'boolean')										throw new TypeError(3);
		if(typeof global !== 'boolean')											throw new TypeError(4);
		if(typeof delay !== 'number')											throw new TypeError(5);
		if(!this.__connections.contains({ where: v => v.ID === connectionID }))	throw new RangeError(6);

		let cursor = {
			ID: !this.__cursors.empty ? Math.max(...this.__windows.map(v => v.ID))+1 : 1,
			layers: layers,
			hotspot: hotspot,
			current: this.__cursors.empty,
			global: global,
			delay: delay
		}

		if(cursor.layers.empty) {
			let layer = cursor.layers[0] = new CGLayer({ width: 32, height: 32 });

			layer.backgroundColor = CGColor(0, 0, 0);
		}

		this.__cursors.add(cursor);
		this.setCurrentCursor(CGSConnection.shared, cursor.ID);

		return cursor.ID;
	}

	getCurrentCursor(connectionID) {}

	getCursorOrigin() {
		return {
			x: this.__cursor.origin.x,
			y: this.__cursor.origin.y
		}
	}

	setCurrentCursor(connectionID, cursorID) {}

	setCursorOrigin(x, y) {
		if(this.__cursors.empty) {
			return;
		}

		this.__cursor.origin.x = x;
		this.__cursor.origin.y = y;

		this.__draw();
	}

	destroyCursor() {}

	async __test() {
	//	let c = CGSConnection.shared;

	//	this.createWorkspace(c);
	//	this.createWorkspace(c);
	//	this.__workspaces[1].layer.context.drawRectangle('rgba(255,120,5,1)', 0, 16, 32, 64);
	//	let l = new CGLayer({ x: 16, y: 32, width: 512, height: 256 });
	//	l.context.drawRectangle('rgba(255,255,255,0.25)', 0, 0, 512, 256);
	//	l.backgroundFilters = [{ title: 'blur', amount: 4 }]
		let l = new CGLayer({ width: CGScreen.size.width, height: CGScreen.size.height });
		l.context.drawLayer(await CGImage.new(LFWorkspace.shared.desktopImageURL), 0, 0, '100', '100');
		let l2 = new CGLayer({ width: l.width, height: l.height });
		l2.backgroundImage = l;
		let m = LFMenubar.shared;
		m.draw();
		this.__workspaces[0].layer.sublayers = [l2, m.__layer]
	//	this.setCurrentWorkspace(c, 2);
	}
}