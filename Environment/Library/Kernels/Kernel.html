<html>
<head>
	<script>
		/**
		 * Opium Kernel
		 *
		 * Ядро окружения. Содержит базовые функции для создания и управления различными низкоуровневыми объектами
		 * (такими как файловые системы, файлы, устройства, события, счётчики, общие окружения,
		 * динамические библиотеки, терминалы и процессы), а также процедуру запуска.
		 *
		 * @version 0.1
		 */

		const Opium = new class Opium {
			__verbose = false;

			uptimeStart = Date.now();
			framebuffer = this.drCreate(this.screen.width, this.screen.height);
			colors = {
				black:		'rgb(0%,0%,0%)',
				darkGray:	'rgb(25%,25%,25%)',
				gray:		'rgb(50%,50%,50%)',
				lightGray:	'rgb(75%,75%,75%)',
				white:		'rgb(100%,100%,100%)',
				yellow:		'rgb(100%,100%,0%)',
				orange:		'rgb(100%,50%,0%)',
				red:		'rgb(100%,0%,0%)',
				magenta:	'rgb(100%,0%,100%)',
				purple:		'rgb(50%,0%,50%)',
				blue:		'rgb(0%,0%,100%)',
				cyan:		'rgb(0%,50%,100%)',
				green:		'rgb(0%,75%,0%)',
				darkGreen:	'rgb(0%,25%,0%)',
				brown:		'rgb(50%,25%,0%)',
				tan:		'rgb(75%,50%,25%)'
			}
			images = {
				font:		'data:image/png;base64,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',
				logo:		'data:image/svg+xml;base64,PHN2ZyB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBpZD0ic3ZnOCIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMTI4IDEyOCIgaGVpZ2h0PSIxMjgiIHdpZHRoPSIxMjgiPiA8ZGVmcyBpZD0iZGVmczIiLz4gPG1ldGFkYXRhIGlkPSJtZXRhZGF0YTUiPiA8cmRmOnJkZj4gPGNjOndvcmsgcmRmOmFib3V0PSIiPiA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4gPGRjOnR5cGUgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIvPiA8ZGM6dGl0bGUvPiA8L2NjOndvcms+IDwvcmRmOnJkZj4gPC9tZXRhZGF0YT4gPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtMTIyOCkiIGlkPSJsYXllcjEiPiA8cGF0aCBpZD0icGF0aDE2NjEiIGQ9Ik0gMzEuOTk5OTgsMTIyOCBBIDMyLDMxLjk5OTk1OCAwIDAgMCAtMi4wMDEwMDI4ZS01LDEyNjAgMzIsMzEuOTk5OTU4IDAgMCAwIDMxLjk5OTk4LDEyOTIgYSAzMS45OTk5MTYsMzEuOTk5OTE2IDAgMCAxIDI0LjAzMTIsLTMwLjk2ODggMzkuOTk5OTcsMzkuOTk5OTE2IDAgMCAxIDAsLTEuMDMxMiAzOS45OTk5NywzOS45OTk5MTYgMCAwIDEgMy41LC0xNi4yOTY4IEEgMzIsMzEuOTk5OTU4IDAgMCAwIDMxLjk5OTk4LDEyMjggWiBtIDY0LjAwMDA0LDAgYSAzMiwzMS45OTk5NTggMCAwIDAgLTMyLjAwMDA0LDMyIDMxLjk5OTkxNiwzMS45OTk5MTYgMCAwIDEgMzAuOTY4ODQsMjQuMDMxMiAzOS45OTk5NywzOS45OTk5MTYgMCAwIDEgMS4wMzEyLDAgMzkuOTk5OTcsMzkuOTk5OTE2IDAgMCAxIDE2LjI5Njc4LDMuNSAzMiwzMS45OTk5NTggMCAwIDAgMTUuNzAzMiwtMjcuNSAzMiwzMS45OTk5NTggMCAwIDAgLTMxLjk5OTk4LC0zMiB6IG0gLTMyLjAwMDA0LDQwIGEgMjMuOTk5OTE2LDIzLjk5OTkxNiAwIDAgMCAtMjQsMjQgMjMuOTk5OTE2LDIzLjk5OTkxNiAwIDAgMCAyNCwyNCAyMy45OTk5MTYsMjMuOTk5OTE2IDAgMCAwIDI0LjAwMDA0LC0yNCAyMy45OTk5MTYsMjMuOTk5OTE2IDAgMCAwIC0yNC4wMDAwNCwtMjQgeiBtIDMyLjAwMDA0LDI0IGEgMzEuOTk5OTE2LDMxLjk5OTkxNiAwIDAgMSAtMjQuMDMxMjQsMzAuOTY4OCAzOS45OTk5NywzOS45OTk5MTYgMCAwIDEgMCwxLjAzMTIgMzkuOTk5OTcsMzkuOTk5OTE2IDAgMCAxIC0zLjUsMTYuMjk2OCAzMiwzMS45OTk5NTggMCAwIDAgMjcuNTAwMDQsMTUuNzAzMiAzMiwzMS45OTk5NTggMCAwIDAgMzEuOTk5OTgsLTMyIDMyLDMxLjk5OTk1OCAwIDAgMCAtMzEuOTk5OTgsLTMyIHogbSAtODAuMjk2ODQsNC41IEEgMzIsMzEuOTk5OTU4IDAgMCAwIC0yLjAwMTAwMjhlLTUsMTMyNCAzMiwzMS45OTk5NTggMCAwIDAgMzEuOTk5OTgsMTM1NiBhIDMyLDMxLjk5OTk1OCAwIDAgMCAzMiwtMzIgMzEuOTk5OTE2LDMxLjk5OTkxNiAwIDAgMSAtMzAuOTY4OCwtMjQuMDMxMiAzOS45OTk5NywzOS45OTk5MTYgMCAwIDEgLTEuMDMxMiwwIDM5Ljk5OTk3LDM5Ljk5OTkxNiAwIDAgMSAtMTYuMjk2OCwtMy41IHoiIHN0eWxlPSJvcGFjaXR5OjE7ZmlsbDojODA4MDgwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjI1O3BhaW50LW9yZGVyOnN0cm9rZSBmaWxsIG1hcmtlcnMiLz4gPC9nPiA8L3N2Zz4=',
				spinner:	'data:image/svg+xml;base64,PHN2ZyB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgdmVyc2lvbj0iMS4xIiBpZD0ic3ZnOCI+IDxkZWZzIGlkPSJkZWZzMiIvPiA8bWV0YWRhdGEgaWQ9Im1ldGFkYXRhNSI+IDxyZGY6cmRmPiA8Y2M6d29yayByZGY6YWJvdXQ9IiI+IDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PiA8ZGM6dHlwZSByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIi8+IDxkYzp0aXRsZS8+IDwvY2M6d29yaz4gPC9yZGY6cmRmPiA8L21ldGFkYXRhPiA8ZyBpZD0ibGF5ZXIxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLC0xMzI0KSI+IDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05NDQsLTM2NzQpIiBpZD0iZzE5MDIiPiA8cmVjdCByeT0iMS41IiByeD0iMS41IiB5PSI0OTk4IiB4PSI5NjAiIGhlaWdodD0iOCIgd2lkdGg9IjMiIGlkPSJyZWN0MTc5NyIgc3R5bGU9Im9wYWNpdHk6MTtmaWxsOiM4MDgwODA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MC4yNTtwYWludC1vcmRlcjpub3JtYWwiLz4gPHJlY3Qgc3R5bGU9Im9wYWNpdHk6MC41NTtmaWxsOiM4MDgwODA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MC4yNTtwYWludC1vcmRlcjpub3JtYWwiIGlkPSJyZWN0MTc5OSIgd2lkdGg9IjMiIGhlaWdodD0iOCIgeD0iOTU3IiB5PSI1MDIyIiByeD0iMS41IiByeT0iMS41Ii8+IDxyZWN0IHRyYW5zZm9ybT0icm90YXRlKDkwKSIgc3R5bGU9Im9wYWNpdHk6MC4zMjU7ZmlsbDojODA4MDgwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjAuMjU7cGFpbnQtb3JkZXI6bm9ybWFsIiBpZD0icmVjdDE4MDEiIHdpZHRoPSIzIiBoZWlnaHQ9IjgiIHg9IjUwMTQiIHk9Ii05NzYiIHJ4PSIxLjUiIHJ5PSIxLjUiLz4gPHJlY3QgdHJhbnNmb3JtPSJyb3RhdGUoOTApIiByeT0iMS41IiByeD0iMS41IiB5PSItOTUyIiB4PSI1MDExIiBoZWlnaHQ9IjgiIHdpZHRoPSIzIiBpZD0icmVjdDE4MDMiIHN0eWxlPSJvcGFjaXR5OjAuNzc1O2ZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjI1O3BhaW50LW9yZGVyOm5vcm1hbCIvPiA8cmVjdCB0cmFuc2Zvcm09InJvdGF0ZSgzMCkiIHN0eWxlPSJvcGFjaXR5OjAuMTc1O2ZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjI1O3BhaW50LW9yZGVyOm5vcm1hbCIgaWQ9InJlY3QxODA1IiB3aWR0aD0iMyIgaGVpZ2h0PSI4IiB4PSIzMzM4LjM4NDMiIHk9IjM4NDYuMjUxIiByeD0iMS41IiByeT0iMS41Ii8+IDxyZWN0IHRyYW5zZm9ybT0icm90YXRlKDMwKSIgcnk9IjEuNSIgcng9IjEuNSIgeT0iMzg3MC4yNTEiIHg9IjMzMzUuMzg0MyIgaGVpZ2h0PSI4IiB3aWR0aD0iMyIgaWQ9InJlY3QxODA3IiBzdHlsZT0ib3BhY2l0eTowLjYyNTtmaWxsOiM4MDgwODA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MC4yNTtwYWludC1vcmRlcjpub3JtYWwiLz4gPHJlY3Qgcnk9IjEuNSIgcng9IjEuNSIgeT0iLTMzNTQuMzg0MyIgeD0iMzg2Mi4yNTEiIGhlaWdodD0iOCIgd2lkdGg9IjMiIGlkPSJyZWN0MTgwOSIgc3R5bGU9Im9wYWNpdHk6MC40O2ZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjI1O3BhaW50LW9yZGVyOm5vcm1hbCIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwKSIvPiA8cmVjdCBzdHlsZT0ib3BhY2l0eTowLjg1O2ZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjI1O3BhaW50LW9yZGVyOm5vcm1hbCIgaWQ9InJlY3QxODExIiB3aWR0aD0iMyIgaGVpZ2h0PSI4IiB4PSIzODU5LjI1MSIgeT0iLTMzMzAuMzg0MyIgcng9IjEuNSIgcnk9IjEuNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwKSIvPiA8cmVjdCByeT0iMS41IiByeD0iMS41IiB5PSIxNjU5LjYxNTUiIHg9IjQ4MjIuMjUxIiBoZWlnaHQ9IjgiIHdpZHRoPSIzIiBpZD0icmVjdDE4MTMiIHN0eWxlPSJvcGFjaXR5OjAuMjU7ZmlsbDojODA4MDgwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjAuMjU7cGFpbnQtb3JkZXI6bm9ybWFsIiB0cmFuc2Zvcm09InJvdGF0ZSg2MCkiLz4gPHJlY3Qgc3R5bGU9Im9wYWNpdHk6MC43O2ZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjI1O3BhaW50LW9yZGVyOm5vcm1hbCIgaWQ9InJlY3QxODE1IiB3aWR0aD0iMyIgaGVpZ2h0PSI4IiB4PSI0ODE5LjI1MSIgeT0iMTY4My42MTU1IiByeD0iMS41IiByeT0iMS41IiB0cmFuc2Zvcm09InJvdGF0ZSg2MCkiLz4gPHJlY3QgdHJhbnNmb3JtPSJyb3RhdGUoMTUwKSIgc3R5bGU9Im9wYWNpdHk6MC40NzU7ZmlsbDojODA4MDgwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjAuMjU7cGFpbnQtb3JkZXI6bm9ybWFsIiBpZD0icmVjdDE4MTciIHdpZHRoPSIzIiBoZWlnaHQ9IjgiIHg9IjE2NzUuNjE1NSIgeT0iLTQ4MzguMjUxIiByeD0iMS41IiByeT0iMS41Ii8+IDxyZWN0IHRyYW5zZm9ybT0icm90YXRlKDE1MCkiIHJ5PSIxLjUiIHJ4PSIxLjUiIHk9Ii00ODE0LjI1MSIgeD0iMTY3Mi42MTU1IiBoZWlnaHQ9IjgiIHdpZHRoPSIzIiBpZD0icmVjdDE4MTkiIHN0eWxlPSJvcGFjaXR5OjAuOTI1O2ZpbGw6IzgwODA4MDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eTowLjI1O3BhaW50LW9yZGVyOm5vcm1hbCIvPiA8L2c+IDwvZz4gPC9zdmc+',
				panic:		'data:image/png;base64,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'
			}
			objects = {
				fs: [],
				files: [],
				devices: [],
				mp: [],
				channels: [],
				catchers: [],
				timers: [],
				se: [],
				dl: [],
				terminals: [],
				processes: []
			}
			eventsReserved = ['keyboardChanged', 'mouseChanged', 'fbChanged', 'terminalChanged', 'processListChanged', 'dateChanged']
			bootTimerID;
			environment;

			async initialize() {
				await this.extensionExecute();

				this.environment = {
					...window,
					Array: Array,
					Date: Date,
					Error: Error,
					Function: undefined,
					JSON: JSON,
					Math: Math,
					Number: Number,
					Object: Object,
					Promise: Promise,
					Proxy: Proxy,
					RangeError: RangeError,
					RegExp: RegExp,
					Symbol: Symbol,
					TypeError: TypeError,
				//	WeakRef: WeakRef,
					console: console,
					eval: (code) => eval(this.codePrepare(code)),
					parseInt: parseInt
				}

				let self = this;

				this.environment.Function = function(...arguments_) {
					let code = arguments_.pop();

					return new Function(...arguments_, self.codePrepare(code));
				}
				this.environment.Function.prototype = Function.prototype;
				this.environment.Function.prototype.constructor = this.environment.Function;

				$(async () => {
					document.querySelectorAll('framebuffer')[0].appendChild(this.framebuffer);

				//	this.verbose = true;

				//	await this.fbWrite();
					await this.bootState(true);

					this.fsRegister('ufs', {
						createDirectory: this.universalFsCreateDirectory,
						destroy: this.universalFsDestroy,
						exists: this.universalFsExists,
						existsDirectory: this.universalFsExistsDirectory,
						statistics: this.universalFsStatistics,
						read: this.universalFsRead,
						readDirectory: this.universalFsReadDirectory,
						write: this.universalFsWrite
					}, 1);
					this.fsRegister('devfs', {
						createNode: this.devicesFsCreateNode,
						destroy: this.devicesFsDestroy,
						exists: this.devicesFsExists,
						existsDirectory: this.devicesFsExistsDirectory,
						statistics: this.devicesFsStatistics,
						read: this.devicesFsRead,
						readDirectory: this.devicesFsReadDirectory,
						write: this.devicesFsWrite,
						control: this.devicesFsControl
					}, 1);
					await this.mpCreate(undefined, 'ufs', undefined, '/', 'u');
					await this.fsCreateDirectory(undefined, '/dev');
					await this.mpCreate(undefined, 'devfs', undefined, '/dev', 'r');

					/*
					await this.deviceInstanceCreate(
						await this.deviceRegister('b', 'disk', undefined, undefined),
						0,
						'disk0s1',
						{ physicalPath: 'G:\\' }
					);
					await this.fsCreateDirectory(undefined, '/Volumes/HD');
					await this.mpCreate(undefined, 'ufs', '/dev/disk0s1', '/Volumes/HD', 'u');
					console.log(await this.fsReadDirectory('/Volumes/HD'));
					*/

					$(document).on('keydown keyup keypress', 'body', (e) => {
						this.eventThrow(undefined, undefined, 'keyboardChanged', { event: e.type, value: e.originalEvent });
					});
					/*
					$(document).on('keydown', 'body', (e) => {
						let key = e.originalEvent.key,
							character = key.length === 1 || ['Backspace', 'Tab', 'Enter'].includes(key) ? key
								.replace('Backspace', '\\b')
								.replace('Tab', '\\t')
								.replace('Enter', '\\n') : '';

						this.fsWrite('/dev/term'+this.terminalCurrent(), character);
					});
					*/
					$(document).on('click dblclick contextmenu mouseover mouseenter mouseout mouseleave mousedown mouseup mousemove', 'body', (e) => {
						if(this.verbose) {
							this.eventThrow(undefined, undefined, 'mouseChanged', { event: e.type, value: e.originalEvent });
						}
					});
					this.eventCatcherCreate(undefined, 'terminalChanged', async (a) => {
						let terminal = this.terminals.find(v => v.ID === a.terminalID),
							string = {
								ID: a.stringID,
								processID: a.processID,
								value: a.value
							},
							process = this.processes.find(v => v.ID === a.processID);

						string.value = process ? process.path.split('/').pop()+': '+string.value : string.value;

						if(a.event === 'output' && terminal.current && terminal.mode === 'text') {
							let layer = this.drCreate(this.screen.width, this.screen.height),
								font = await this.drOpen(this.images.font),
								alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~',
								width = 8,
								height = 16;

							this.drDraw(layer, 'rectangle', this.colors.black, 0, string.ID*height-height, string.value.length*width, height);
							for(let i in string.value) {
								let position = alphabet.indexOf(string.value[i]);

								if(position > -1) {
									let symbol = this.drCreate(width, height);

									this.drDraw(symbol, 'rectangle', this.colors.white, 0, 0, width, height);
									this.drMask(symbol, this.drClip(font, position*width, 0, width, height));
									this.drDraw(layer, 'layer', symbol, i*width, string.ID*height-height);
								}
							}
							this.fbWrite(undefined, layer);
						}
					});
					this.timerCreate(undefined, true, 1000, () => {
						this.eventThrow(undefined, undefined, 'dateChanged');
					});

					for(let v of ['fs', 'fast-xml-parser', 'child_process', 'vm', 'recast', 'flow-parser', 'os']) {
						require(v);
					}
					this.processExecute(undefined, undefined, 'root', 'root', '/Environment/Library/Applications/Login.app/Contents/Executables/Login').then(() => {
						this.bootState(false);
					}, error => {
						this.kdbPanic(error);
					});
				});

				return this;
			}

			/**
			 * Версия ядра и Окружения.
			 */
			get version() {
				return {
					kernel: [
						'Opium Kernel',
						0.1
					],
					DE: [
						'Poppy DE',
						0.1
					]
				}
			}

			get verbose() {
				return this.__verbose;
			}

			/**
			 * Время с момента запуска Окружения в миллисекундах.
			 *
			 * @returns {number}
			 */
			get uptime() {
				return new Date(Date.now()-this.uptimeStart).getTime();
			}

			/**
			 * Разрешение экрана.
			 */
			get screen() {
				return {
					width: window.innerWidth,
					height: window.innerHeight
				}
			}

			/**
			 * File Systems - Объекты файловых систем.
			 *
			 * @returns {Object[]}
			 */
			get fs() {
				return this.objects.fs;
			}

			/**
			 * Mount Points - Точки монтирования.
			 *
			 * @returns {Object[]}
			 */
			get mp() {
				return this.objects.mp;
			}

			/**
			 * Объекты файлов.
			 *
			 * @returns {Object[]}
			 */
			get files() {
				return this.objects.files;
			}

			/**
			 * Объекты устройств.
			 *
			 * @returns {Object[]}
			 */
			get devices() {
				return this.objects.devices;
			}

			/**
			 * Объекты каналов событий.
			 *
			 * @returns {Object[]}
			 */
			get channels() {
				return this.objects.channels;
			}

			/**
			 * Объекты отловщиков событий.
			 *
			 * @returns {Object[]}
			 */
			get catchers() {
				return this.objects.catchers;
			}

			/**
			 * Объекты таймеров.
			 *
			 * @returns {Object[]}
			 */
			get timers() {
				return this.objects.timers;
			}

			/**
			 * Shared Environments - Объекты общих окружений.
			 *
			 * @returns {Object[]}
			 */
			get se() {
				return this.objects.se;
			}

			/**
			 * Dynamic Libraries - Объекты динамических библиотек.
			 *
			 * @returns {Object[]}
			 */
			get dl() {
				return this.objects.dl;
			}

			/**
			 * Объекты терминалов.
			 *
			 * @returns {Object[]}
			 */
			get terminals() {
				return this.objects.terminals;
			}

			/**
			 * Объекты процессов.
			 *
			 * @returns {Object[]}
			 */
			get processes() {
				return this.objects.processes;
			}

			set verbose(value) {
				if(typeof value !== 'boolean') {
					return;
				}

				this.__verbose = value;
				if(value) {
					$('body').attr('verbose', '');
				} else {
					$('body').removeAttr('verbose');
				}
			}

			set fs(value) {
				this.objects.fs = value;
			}

			set mp(value) {
				this.objects.mp = value;
			}

			set files(value) {
				this.objects.files = value;
			}

			set devices(value) {
				this.objects.devices = value;
			}

			set channels(value) {
				this.objects.channels = value;
			}

			set catchers(value) {
				this.objects.catchers = value;
			}

			set timers(value) {
				this.objects.timers = value;
			}

			set se(value) {
				this.objects.se = value;
			}

			set dl(value) {
				this.objects.dl = value;
			}

			set terminals(value) {
				this.objects.terminals = value;
			}

			set processes(value) {
				this.objects.processes = value;
			}

			kdInfo(...a) {
				for(let v of a) {
					let b = v?.replace(/^\t*/gm, '').trim().split(/^/gm) ?? []

					for(let v_ of b) {
						if(this.verbose) {
							let c = $('kdb strings');

							c.append('<string><text>'+v_+'</text></string>');
							c[0].scrollTop = c[0].scrollHeight;
						//	this.terminalOutput(undefined, v_, 1);
						}
						console.log(v_);
					}
				}
			}

			kdbClear() {
				$('kdb strings').text('');
			}

			async kdbPanic(error = {}) {
				for(let v of this.timers) {
					this.timerDestroy(undefined, v.ID);
				}
				this.kdbClear();
				this.kdInfo(`
					Please contact someone with an image of the
					information printed below, along with a description of your
					environment configuration and what you were doing at the time that
					the kernel panic occurred. We apologize for the inconvenience.

					panic: "${ error.name }: ${ error.message }"@${ error.fileName }:${ error.lineNumber }

					${ error.stack }

					Process title corresponding to current thread: ${ error.fileName?.split('/').pop() }

					Kernel version:
					${ this.version.kernel?.join(' Version ') ?? 'Not yet set' }

					DE version:
					${ this.version.DE?.pop() ?? 'Not yet set' }

					Environment uptime in milliseconds: ${ this.uptime }
				`);
				$('kdb').attr('panic', '');

				let layer = this.drCreate(this.screen.width, this.screen.height),
					image = await this.drOpen(this.images.panic);

				this.drDraw(layer, 'rectangle', 'rgba(0%,0%,0%,0.25)', 0, 0, layer.width, layer.height);
				this.drDraw(layer, 'layer', image, layer.width/2-image.width/2, layer.height/2-image.height/2);
				this.fbWrite(undefined, layer);
			}

			async bootState(value) {
				return {
					false: () => {
						if(this.bootTimerID != null) {
							this.timerDestroy(undefined, this.bootTimerID);

							this.bootTimerID = undefined;
						}
					},
					true: async () => {
						if(this.bootTimerID == null) {
							let layer = this.drCreate(this.screen.width, this.screen.height),
								logo = await this.drOpen(this.images.logo),
								spinner = await this.drOpen(this.images.spinner),
								spinnerBackground = this.drCreate(spinner.width, spinner.height),
								spinnerIteration = 0;

							this.drDraw(layer, 'rectangle', this.colors.lightGray, 0, 0, layer.width, layer.height);
							this.drDraw(layer, 'layer', logo, layer.width/2-logo.width/2, layer.height/2-logo.height/2);
							this.drDraw(spinnerBackground, 'rectangle', this.colors.lightGray, 0, 0, spinnerBackground.width, spinnerBackground.height);

							this.bootTimerID = this.timerCreate(undefined, true, 125/2, async () => {
								spinnerIteration = spinnerIteration > 10 ? 0 : ++spinnerIteration;

								let x = layer.width/2,
									y = layer.height/2+(layer.height+logo.height)/4,
									angle = 30*spinnerIteration;

								this.drDraw(layer, 'layer', spinnerBackground, x, y, undefined, undefined, angle);
								this.drDraw(layer, 'layer', spinner, x, y, undefined, undefined, angle);
								this.fbWrite(undefined, layer);
							});
						}
					}
				}[value]();
			}

			/**
			 * Заменяет лишние и обратные `/` в пути на одинарные.
			 */
			urlPathNormalize(path) {
				return path.replace(/[\\/]+/gm, '/');
			}

			/**
			 * Возвращает информацию о пути, включающую в себя оригинальные объекты:
			 * - Файловая система.
			 * - Устройство.
			 * - Экземпляр устройства.
			 * - Точка монтирования.
			 *
			 * @param	{string} path Абсолютный путь к файлу или директории.
			 * @returns	{?Object}
			 */
			async urlPathInfo(path) {
				if(typeof path !== 'string') {
					throw new TypeError('Incorrect path');
				}

				for(let mp of this.mp.sort((a, b) => b.targetPath.length-a.targetPath.length)) {
					if(path.startsWith(mp.targetPath)) {
						let info = {
							fs: this.fs.find(v => v.ID === mp.fsID),
							device: undefined,
							deviceInstance: undefined,
							mp: mp
						}

						if(mp.sourcePath) {
							let deviceStatistics = await this.fsStatistics(mp.sourcePath);

							info.device = this.devices.find(v => v.ID === deviceStatistics.internalDeviceMajorID && v.type === deviceStatistics.type.replace('inode/chardevice', 'c').replace('inode/blockdevice', 'b'));
							info.deviceInstance = info.device.instances.find(v => v.ID === deviceStatistics.internalDeviceMinorID);
						}

						return info;
					}
				}
			}

			/**
			 * Регистрирует файловую систему и возвращает её идентификатор.
			 *
			 * После монтирования взаимодействие с файлами в ней производится посредством развилочных методов ФС.
			 *
			 * Любая полноценная ФС должна обладать реализацией всех нижеперечисленных методов:
			 * - `createDirectory(path)` - Создание директории.
			 * - `destroy(path)` - Удаление файла.
			 * - `exists(path)` - Возврат логического значения, указывающего, существует ли файл.
			 * - `existsDirectory(path)` - Возврат логического значения, указывающего, существует ли директория.
			 * - `statistics(path)` - Возврат статистики файла или директории, такой как:
			 *   - `deviceID` - Идентификатор устройства хранения.
			 *   - `type` - Тип в формате MIME.
			 *   - `size`- Размер в байтах.
			 * - `read(path, raw)` - Чтение файла.
			 * - `readDirectory(path)` - Возврат массива `Dirent`'ов.
			 * - `write(path, content)` - Запись данных в файл.
			 *
			 * ФС, работающая с файлами устройств, также должна иметь методы вида:
			 * - `createNode(processID, path, type, deviceMajorID, deviceMinorID)` - Создание файла устройства.
			 * - `statistics(path)` - Дополнительное свойство:
			 *   - `internalDeviceID` - Идентификатор устройства, отражённый в файле.
			 * - `control(path, ...arguments_)` - Управление устройством: отправка команд, изменение его свойств и т.д.
			 *
			 * @param	{string}	title		Название.
			 * @param	{Object}	functions	Функции.
			 * @param	{0|1}		type		Тип: физический или виртуальный. Указывает на то, может ли ФС использоваться без устройства-источника.
			 * @returns	{number}
			 */
			async fsRegister(title, functions = {}, type = 0) {
				if(typeof title !== 'string')				throw new TypeError('Incorrect title');
				if(!Object.isObject(functions))				throw new TypeError('Incorrect functions');
				for(let k in functions) {
					if(typeof functions[k] !== 'function')	throw new TypeError('Incorrect function: '+k);
				}
				if(typeof type !== 'number')				throw new TypeError('Incorrect type');
				if(this.fs.find(v => v.title === title))	throw new RangeError('Object with same title already exists');
				if(![0, 1].includes(type))					throw new RangeError('Incorrect type');

				let ID = this.fs.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				for(let k in functions) {
					functions[k] = functions[k].bind(this);
				}
				this.fs.push({
					ID: ID,
					title: title,
					functions: functions,
					type: type
				});
				this.kdInfo(`
					fsRegister: Object created:
					    ID: ${ ID }
					    Title: ${ title ? '"'+title+'"' : 'Not set' }
					    Type: ${ type === 0 ? 'Physical' : 'Virtual' }
				`);

				return ID;
			}

			/**
			 * Разрегистрирует файловую систему.
			 *
			 * @param {string|number} fsSearch
			 */
			fsUnregister(fsSearch) {
				let fs = this.fs.find(v => v.ID === fsSearch || v.title === fsSearch);

				if(!fs) {
					if(this.verbose) {
						this.kdInfo(`fsUnregister: Unable to find object`);
					}

					return;
				}

				this.fs = this.fs.filter(v => v !== fs);
				this.kdInfo(`fsUnregister: Object ${ fs.ID } destroyed`);
			}

			async fsCreateDirectory(processID, path) {
				return (await this.urlPathInfo(path))?.fs.functions.createDirectory?.(...arguments);
			}

			async fsCreateNode(processID, path, deviceMajorID, deviceMinorID) {
				return (await this.urlPathInfo(path))?.fs.functions.createNode?.(...arguments);
			}

			async fsDestroy(path) {
				return (await this.urlPathInfo(path))?.fs.functions.destroy?.(...arguments);
			}

			async fsExists(path) {
				return (await this.urlPathInfo(path))?.fs.functions.exists?.(...arguments);
			}

			async fsExistsDirectory(path) {
				return (await this.urlPathInfo(path))?.fs.functions.existsDirectory?.(...arguments);
			}

			async fsStatistics(path) {
				return (await this.urlPathInfo(path))?.fs.functions.statistics?.(...arguments);
			}

			/**
			 * Открывает файл в одном из следующих режимов и возвращает его идентификатор (относительный процессу):
			 * - `r` - Чтение. При открытии поток располагается в начале.
			 * - `r+` - Запись и чтение. При открытии поток располагается в начале.
			 * - `w` - Запись. При открытии файл создаётся или усекается до нуля, а поток располагается в начале.
			 * - `w+` - Запись и чтение. При открытии файл создаётся или усекается до нуля, а поток располагается в начале.
			 * - `a` - Запись. При открытии файл создаётся, если его не существует. Поток всегда располагается в конце.
			 * - `a+` - Запись и чтение. При открытии файл создаётся, если его не существует. Поток всегда располагается в конце.
			 *
			 * @param	{number}						processID	Идентификатор процесса.
			 * @param	{string}						path		Абсолютный путь.
			 * @param	{'r'|'r+'|'w'|'w+'|'a'|'a+'}	mode		Режим.
			 * @returns	{number}
			 */
			async fsOpen(processID, path, mode = 'r') {
				if(processID && typeof processID !== 'number')					throw new TypeError('Incorrect process ID');
				if(typeof path !== 'string')									throw new TypeError('Incorrect path');
				if(typeof mode !== 'string')									throw new TypeError('Incorrect mode');
				if(!['r', 'r+', 'w', 'w+', 'a', 'a+'].includes(mode))			throw new RangeError('Incorrect mode');
				if(['r', 'r+'].includes(mode) && !await this.fsExists(path))	throw new RangeError('Unable to find file');

				let ID = this.files.filter(v => v.processID === processID).reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				this.files.push({
					ID: ID,
					processID: processID,
					path: path,
					mode: mode,
					position: !['a', 'a+'].includes(mode) ? 0 : ((await this.fsStatistics(path))?.size ?? -1)+1
				});
				this.kdInfo(`
					fsOpen${ processID ? '@'+processID : '' }: Object created:
					    ID: ${ ID }
					    Path: ${ path }
					    Mode: ${ mode }
				`);

				return ID;
			}

			async fsClose(processID, fileID) {
				if(processID && typeof processID !== 'number')	throw new TypeError('Incorrect process ID');
				if(typeof fileID !== 'number')					throw new TypeError('Incorrect file ID');

				let file = this.files.find(v => v.ID === fileID && v.processID === processID);

				if(!file) {
					if(this.verbose) {
						this.kdInfo(`fsClose${ processID ? '@'+processID : '' }: Unable to find object`);
					}

					return;
				}

				this.files = this.files.filter(v => v !== file);
			}

			/**
			 * Устанавливает позицию потока, если возможно.
			 *
			 * @param {number}	processID	Идентификатор процесса.
			 * @param {number}	fileID		Идентификатор файла.
			 * @param {number}	position	Позиция.
			 * @param {0|1|2}	mode		Режим относительности: 0 - начало, 1 - текущая позиция, 2 - конец.
			 */
			async fsSeek(processID, fileID, position, mode = 0) {
				if(processID && typeof processID !== 'number')	throw new TypeError('Incorrect process ID');
				if(typeof fileID !== 'number')					throw new TypeError('Incorrect file ID');
				if(typeof position !== 'number')				throw new TypeError('Incorrect position');
				if(typeof mode !== 'number')					throw new TypeError('Incorrect mode');

				let file = this.files.find(v => v.ID === fileID && v.processID === processID);

				if(!file)										throw new RangeError('Unable to find object');
				if(processID && processID !== file.processID)	throw new Error(`Processes aren't allowed to modify not owned file streams positions`);
				if(position < 0)								throw new RangeError('Incorrect position');
				if(![0, 1, 2].includes(mode))					throw new RangeError(`Incorrect mode`);

				file.position = mode === 0 ? position : mode === 1 ? file.position+position : mode === 2 ? ((await this.fsStatistics(file.path))?.size ?? 0)+position : undefined;
			}

			async fsRead(path, raw = false) {
				return (await this.urlPathInfo(path))?.fs.functions.read?.(...arguments);
			}

			async fsReadBasic(path, raw) {
				try {
					let c = await require('fs').promises.readFile('.'+path);

					return /\.(png|jpe?g|gif|svg|pdf)$/gi.test(path) || raw ? c : c.toString();
				} catch {}
			}

			async fsReadDirectory(path) {
				return (await this.urlPathInfo(path))?.fs.functions.readDirectory?.(...arguments);
			}

			async fsReadDirectoryBasic(path) {
				try {
					return require('fs').promises.readdir('.'+path, { withFileTypes: true });
				} catch {
					return []
				}
			}

			async fsReadPreferences(process, identifier) {
				let properties =
					(process ? await this.fsRead('/Users/'+process.user+'/Library/Preferences/'+identifier+'.plist') : undefined) ??
					await this.fsRead('/Library/Preferences/'+identifier+'.plist') ??
					await this.fsRead('/Environment/Library/Preferences/'+identifier+'.plist');

				return properties ? JSON.parse(properties) : undefined;
			}

			async fsWrite(path, content) {
				return (await this.urlPathInfo(path))?.fs.functions.write?.(...arguments);
			}

			async fsWritePreferences(process, identifier, properties, type) {
				let group = (await this.fsReadPreferences(undefined, 'Global')).Users.find(v => v.Login === process?.user)?.Group;

				type ??= process ? 'user' : 'shared';

				if(!['string', 'number'].includes(typeof identifier))			throw new RangeError('Incorrect identifier');
				if(!Object.isObject(properties))								throw new TypeError('Incorrect properties');
				if(type && !['user', 'shared', 'environment'].includes(type))	throw new TypeError('Incorrect type');
				if(type === 'user' && !process)									throw new Error('Unable to find user without process set');
				if(type === 'environment' && group > 0)							throw new Error(`Groups 1+ aren't allowed to write environment-wide preferences`);

				properties = JSON.stringify(properties);

				return {
					user:			() => this.fsWrite('/Users/'+process.user+'/Library/Preferences/'+identifier+'.plist', properties),
					shared:			() => this.fsWrite('/Library/Preferences/'+identifier+'.plist', properties),
					environment:	() => this.fsWrite('/Environment/Library/Preferences/'+identifier+'.plist', properties)
				}[type]();
			}

			async fsControl(path, ...arguments_) {
				return (await this.urlPathInfo(path))?.fs.functions.control?.(...arguments);
			}

			/**
			 * Регистрирует устройство и возвращает его старший идентификатор.
			 *
			 * @param	{'c'|'b'}	type			Тип: символьный или блочный.
			 * @param	{string}	title			Название. Зачастую сокращённое, например "fb" (FrameBuffer) или "disk". Может состоять только из символов [a-zA-Z0-9-/].
			 * @param	{?string}	description		Описание. Зачастую - реальное, полное название.
			 * @param	{Object}	functions		Функции: `read(path, raw)`, `write(path, content)` и `control(...arguments_)`.
			 * @returns	{number}
			 */
			deviceRegister(type, title, description, functions = {}) {
				if(typeof type !== 'string')						throw new TypeError('Type should be string');
				if(typeof title !== 'string')						throw new TypeError('Title should be string');
				if(description && typeof description !== 'string')	throw new TypeError('Description should be string or void');
				if(!Object.isObject(functions))						throw new TypeError('Functions should be object');
				for(let k in functions) {
					if(typeof functions[k] !== 'function')			throw new TypeError('Is not function: '+k);
				}
				if(!['c', 'b'].includes(type))						throw new RangeError(`Type should be 'c' or 'b'`);
				if(!/^[a-z0-9-/]+$/i.test(title))					throw new RangeError('Title should match [a-zA-Z0-9-/]');

				let ID = this.devices.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				this.devices.push({
					ID: ID,
					instances: [],
					type: type,
					title: title,
					description: description,
					functions: functions
				});
				this.kdInfo(`
					deviceRegister: Object created:
					    ID: ${ ID }
					    Type: ${ type === 'c' ? 'Character' : 'Block' }
					    Title: ${ title }
					    Description: ${ description ? '"'+description+'"' : 'Not set' }
				`);

				return ID;
			}

			/**
			 * Разрегистрирует устройство.
			 *
			 * @param {number} deviceMajorID Старший идентификатор устройства.
			 */
			deviceUnregister(deviceMajorID) {
				let device = this.devices.find(v => v.ID === deviceMajorID);

				if(!device) {
					if(this.verbose) {
						this.kdInfo(`deviceUnregister: Unable to find object`);
					}

					return;
				}

				this.devices = this.devices.filter(v => v !== device);
				this.kdInfo(`deviceUnregister: Object ${ device.ID } destroyed`);
			}

			/**
			 * Создаёт экземпляр устройства и возвращает его младший идентификатор.
			 *
			 * @param {number}	deviceMajorID	Старший идентификатор устройства.
			 * @param {?number}	deviceMinorID	Младший идентификатор устройства.
			 * @param {string}	title			Название. Зачастую сокращённое и включающее идентификатор, например "fb0" (FrameBuffer 0) или "disk0s1" (Disk 0 Sector 1). Может состоять только из символов [a-zA-Z0-9-/].
			 * @param {Object}	data			Данные.
			 */
			async deviceInstanceCreate(deviceMajorID, deviceMinorID, title, data = {}) {
				if(typeof deviceMajorID !== 'number')					throw new TypeError('Device major ID should be number');
				if(deviceMinorID && typeof deviceMinorID !== 'number')	throw new TypeError('Device minor ID should be number or void');
				if(typeof title !== 'string')							throw new TypeError('Title should be string');
				if(!Object.isObject(data))								throw new TypeError('Data should be object');
				if(deviceMajorID < 0)									throw new RangeError('Device major ID should be >= 0');
				if(deviceMinorID && deviceMinorID < 0)					throw new RangeError('Device minor ID should be >= 0');
				if(title.length === 0)									throw new RangeError('Title length should be >= 1');

				let device = this.devices.find(v => v.ID === deviceMajorID),
					ID = deviceMinorID ?? device?.instances.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				if(!device)									throw new RangeError('Unable to find object');
				if(device.instances.find(v => v.ID === ID))	throw new RangeError(`Object ${ ID } already exists`);

				device.instances.push({
					ID: ID,
					title: title,
					data: data
				});
				await this.fsCreateNode(undefined, '/dev/'+title, device.type, deviceMajorID, deviceMinorID);

				return ID;
			}

			deviceInstanceDestroy(deviceMajorID, deviceMinorID) {

			}

			/**
			 * Возвращает список идентификаторов устройств.
			 *
			 * @returns {number[]}
			 */
			deviceList() {
				return this.devices.map(v => v.ID);
			}

			/**
			 * Возвращает информацию об устройстве.
			 *
			 * @param	{number}	processID		Идентификатор процесса.
			 * @param	{number}	deviceMajorID	Старший идентификатор устройства.
			 * @returns	{?Object}
			 */
			deviceInfo(processID, deviceMajorID) {
				if(!['number', 'string'].includes(typeof deviceSearch)) {
					throw new TypeError('Incorrect search');
				}

				let device = this.devices.find(v => v.ID === deviceMajorID);

				if(!device) {
					if(this.verbose) {
						this.kdInfo(`deviceInfo${ processID ? '@'+processID : '' }: Unable to find object`);
					}

					return;
				}

				return {
					majorID: device.ID,
					minorIDs: device.instances.map(v => v.ID),
					type: device.type,
					title: device.title,
					description: device.description
				}
			}

			/**
			 * Возвращает конечный физический путь: абсолютный (если точке монтирования назначено устройство,
			 * обладающее этой информацией) или относительный.
			 *
			 * @param	{string} path
			 * @returns	{string}
			 */
			async universalFsDestination(path) {
				if(typeof path !== 'string') {
					throw new TypeError('Incorrect path');
				}

				let info = await this.urlPathInfo(path),
					physicalPath = info?.deviceInstance?.data.physicalPath;

				return this.urlPathNormalize(physicalPath ? physicalPath+'/'+path.replace(new RegExp('^'+info.mp.targetPath), '') : /^[\\/]+/g.test(path) ? '.'+path : path);
			}

			async universalFsCreateDirectory(processID, path) {
				if(await this.fsExistsDirectory(path)) {
					return;
				}
				try {
					await require('fs').promises.mkdir(await this.universalFsDestination(path), { recursive: true });
				} catch(error) {
					throw 'Unable to create directory: '+error.message;
				}
			}

			async universalFsExists(path) {
				let finalPath = await this.universalFsDestination(path);

				try {
					return await require('fs').promises.access(finalPath) === undefined && (await require('fs').promises.stat(finalPath)).isFile();
				} catch {
					return false;
				}
			}

			async universalFsExistsDirectory(path) {
				let finalPath = await this.universalFsDestination(path);

				try {
					return await require('fs').promises.access(finalPath) === undefined && (await require('fs').promises.stat(finalPath)).isDirectory();
				} catch {
					return false;
				}
			}

			async universalFsStatistics(path) {
				let title = path.split('/').at(-1),
					data,
					type,
					size;

				if(await this.universalFsExists(path)) {
					data = await this.universalFsRead(path, true);
				} else
				if(await this.universalFsExistsDirectory(path)) {
					type = 'inode/directory';
				} else {
					return;
				}

				let types = [
					{
						mime: 'image/gif',
						magic: [71, 73, 70, 56, 57, 97],
						extension: 'gif'
					},
					{
						mime: 'image/jpeg',
						magic: [255, 216, 255, 224, 0, 16, 74, 70, 73, 70, 0, 1, 1],
						extension: 'jpe?g'
					},
					{
						mime: 'image/png',
						magic: [137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0],
						extension: 'png'
					},
					{
						mime: 'image/svg+xml',
						content: (a) => {
							try {
								for(let k in require('fast-xml-parser').parse(a)) {
									if(k === 'svg') {
										return true;
									}
								}
							} catch {}
						},
						extension: 'svg'
					},
					{
						mime: 'application/pdf',
						magic: [37, 80, 68, 70, 45, 49, 46],
						extension: 'pdf'
					}
				]

				if(!type) {
					for(let v of types) {
						if(v.magic && data.startsWith(v.magic)) {
							type = v.mime; break;
						}
					}
				}
				if(!type) {
					for(let v of types) {
						if(v.content?.(data.toString())) {
							type = v.mime; break;
						}
					}
				}
				if(!type && title) {
					for(let v of types) {
						if(v.extension && new RegExp('/\.' + v.extension + '$/gi').test(title)) {
							type = v.mime; break;
						}
					}
				}

				if(!this.mp.find(v => v.targetPath === path)) {
					try {
						size = (await require('fs').promises.stat('.'+path)).size;
					} catch {}
				} else {
					size = 0;
				}

				let info = await this.urlPathInfo(path);

				return {
					deviceMajorID: info.device?.ID,
					deviceMinorID: info.deviceInstance?.ID,
					type: type,
					size: size
				}
			}

			async universalFsRead(path, raw) {
				let finalPath = await this.universalFsDestination(path);

				if(await this.universalFsExists(path)) {
					let c = await require('fs').promises.readFile(finalPath);

					return /\.(png|jpe?g|gif|svg|pdf)$/gi.test(path) || raw ? c : c.toString();
				} else {
					if(this.verbose) {
						this.kdInfo('fsRead: Unable to access file: '+path);
					}
				}
			}

			async universalFsReadDirectory(path) {
				let finalPath = await this.universalFsDestination(path);

				if(await this.universalFsExistsDirectory(path)) {
					return require('fs').promises.readdir(finalPath, { withFileTypes: true });
				} else {
					if(this.verbose) {
						this.kdInfo('fsReadDirectory: Unable to access directory: '+path);
					}

					return []
				}
			}

			async universalFsWrite(path, content) {
				let finalPath = await this.universalFsDestination(path),
					event = await this.universalFsExists(path) ? 'written' : 'created';

				try {
					await require('fs').promises.writeFile(finalPath, content, { flag: 'w' });
					await this.eventThrow(undefined, undefined, 'fsChanged', { event: event, value: path });

					return true;
				} catch(error) {
					throw new Error(`Can't write to file: `+error.message);
				}
			}

			async universalFsDestroy(path) {
				let finalPath = await this.universalFsDestination(path);

				if(await this.universalFsExists(path)) {
					try {
						await require('fs').promises.unlink(finalPath);

						return true;
					} catch(error) {
						throw new Error('Unable to remove file: '+error.message);
					}
				} else {
					if(this.verbose) {
						this.kdInfo('fsDestroy: Unable to access file: '+path);
					}
				}
			}

			devicesFsData = []

			async devicesFsCreateNode(processID, path, type, deviceMajorID, deviceMinorID) {
				if(processID && typeof processID !== 'number')	throw new TypeError('Process ID should be number or void');
				if(typeof path !== 'string')					throw new TypeError('Path should be string');
				if(typeof type !== 'string')					throw new TypeError('Type should be string');
				if(typeof deviceMajorID !== 'number')			throw new TypeError('Device major ID should be number');
				if(typeof deviceMinorID !== 'number')			throw new TypeError('Device minor ID should be number');
				if(!['c', 'b'].includes(type))					throw new RangeError(`Type should be 'c' or 'b'`);

				path = this.urlPathNormalize(path);

				if(await this.fsExists(path) || await this.fsExistsDirectory(path))			throw new RangeError(`Unable to create file: Already exists: "${ path }"`);
				if(!await this.fsExistsDirectory(path.substring(0, path.lastIndexOf('/'))))	throw new RangeError(`Unable to create file: Directory does not exists: "${ path }"`);

				this.devicesFsData.push({
					path: path,
					type: type,
					deviceMajorID: deviceMajorID,
					deviceMinorID: deviceMinorID
				});
			}

			devicesFsDestroy(path) {
				this.devicesFsData = this.devicesFsData.filter(v => v.path !== this.urlPathNormalize(path));
			}

			devicesFsExists(path) {
				return this.devicesFsData.find(v => v.path === this.urlPathNormalize(path)) !== undefined;
			}

			async devicesFsExistsDirectory(path) {
				return path === (await this.urlPathInfo(path))?.mp.targetPath;
			}

			async devicesFsStatistics(path) {
				let info = await this.urlPathInfo(path);

				if(path === info?.mp.targetPath) return {
					deviceMajorID: info.device?.ID,
					deviceMinorID: info.deviceInstance?.ID,
					type: 'inode/directory',
					size: 0
				}

				let file = this.devicesFsData.find(v => v.path === path);

				if(file) return {
					deviceMajorID: info?.device?.ID,
					deviceMinorID: info?.deviceInstance?.ID,
					internalDeviceMajorID: file.deviceMajorID,
					internalDeviceMinorID: file.deviceMinorID,
					type: file.type === 'c' ? 'inode/chardevice' : file.type === 'b' ? 'inode/blockdevice' : undefined,
					size: 0
				}
			}

			devicesFsDevice(path) {
				return this.devices.find(v => v.ID === this.devicesFsData.find(v => v.path === path).deviceMajorID);
			}

			devicesFsRead(path) {
				return this.devicesFsDevice(path)?.functions.read?.(...arguments);
			}

			async devicesFsReadDirectory(path) {
				let mp = (await this.urlPathInfo(path))?.mp;

				if(mp && path === mp.targetPath) {
					return this.devicesFsData.filter(v => v.path.startsWith(path)).map(v => new (require('fs')).Dirent(v.path.split('/').pop(), 1));
				}
			}

			devicesFsWrite(path, content) {
				return this.devicesFsDevice(path)?.functions.write?.(...arguments);
			}

			devicesFsControl(path, ...arguments_) {
				return this.devicesFsDevice(path)?.functions.control?.(...arguments);
			}

			/**
			 * Создаёт точку монтирования.
			 *
			 * Применяется к блочным устройствам и ФС, для доступа к ним.
			 *
			 * @param {processID}		processID	Идентификатор процесса.
			 * @param {string|number}	fsSearch	Название или идентификатор ФС.
			 * @param {?string}			sourcePath	Абсолютный путь блочного устройства-источника. Может не указываться, если ФС это поддерживает.
			 * @param {string}			targetPath	Абсолютный путь директории-цели.
			 * @param {'r'|'u'}			access		Уровень доступа: чтение или чтение/запись.
			 */
			async mpCreate(processID, fsSearch, sourcePath, targetPath, access) {
				if(!['string', 'number'].includes(typeof fsSearch))	throw new TypeError('Incorrect search');
				if(sourcePath && typeof sourcePath !== 'string')	throw new TypeError('Incorrect source');
				if(typeof targetPath !== 'string')					throw new TypeError('Incorrect target');
				if(typeof access !== 'string')						throw new TypeError('Incorrect access');
				if(!['r', 'u'].includes(access))					throw new RangeError('Incorrect access');

				let fs = this.fs.find(v => v.ID === fsSearch || v.title === fsSearch);

				if(!fs) {
					throw new RangeError(`Unable to find FS ${ typeof fsSearch === 'number' ? fsSearch : '"'+fsSearch+'"' }`);
				}
				if(fs.type === 0 && (await this.fsStatistics(sourcePath))?.type !== 'inode/blockdevice') {
					throw new Error(`"${ sourcePath }" is not a block device`);
				}
				if(sourcePath && this.mp.find(v => v.sourcePath === sourcePath)) {
					throw new Error(`"${ sourcePath }" already mounted`);
				}
				if(targetPath !== '/' && !await this.fsExistsDirectory(targetPath)) {
					throw new Error(`"${ targetPath }" is not a directory`);
				}

				let ID = this.mp.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				this.mp.push({
					ID: ID,
					fsID: fs.ID,
					sourcePath: sourcePath,
					targetPath: targetPath,
					access: access
				});
				this.kdInfo(`
					mpCreate${ processID ? '@'+processID : '' }: Object created:
					    ID: ${ ID }
					    FS ID: ${ fs.ID }
					    Source Path: ${ sourcePath ? '"'+sourcePath+'"' : 'Not set' }
					    Target Path: "${ targetPath }"
					    Access: ${ access === 'r' ? 'Read' : 'Read-Write' }
				`);

				return ID;
			}

			/**
			 * Уничтожает точку монтирования.
			 */
			mpDestroy(processID, targetPath) {}

			async extensionExecute(...a) {
				a = Array.isArray(a) ? a : []

				if(a.length === 0) {
					for(let v of await this.fsReadDirectoryBasic('/Environment/Library/Extensions')) {
						a.push(v.name.replace('.kext', ''));
					}
				}

				for(let v of a) {
					let b = `/Environment/Library/Extensions/${ v }.kext/Contents/Executables/${ v }`,
						c = await this.fsReadBasic(b);

					if(c) {
						this.kdInfo('extensionExecute: Loading: '+b);
					//	window[v] = require(`../Extensions/${ v }.kext/Contents/Classes/${ v }`);
						new Function(c)();
					}
				}
			}

			workerCreate(code) {
				return new Worker(URL.createObjectURL(new Blob([code], { type: 'application/javascript' })));
			}

			fbRead() {
				return this.drClose(this.framebuffer);
			}

			async fbWrite(process, value) {
				let group = (await this.fsReadPreferences(undefined, 'Global')).Users.find(v => v.Login === process?.user)?.Group;

				if(process && group > 0) {
					throw new Error(`Groups 1+ aren't allowed to write to framebuffer`);
				}
				if(value !== undefined && !value instanceof Buffer && !value instanceof HTMLCanvasElement) {
					throw new TypeError(`Incorrect value`);
				}

				let layer = this.framebuffer;

				if(value === undefined) {
					this.drDraw(layer, 'rectangle', this.colors.black, 0, 0, layer.width, layer.height);
				}
				if(value instanceof Buffer) {
					this.drDraw(layer, 'layer', await this.drOpen(value));
				}
				if(value instanceof HTMLCanvasElement) {
					this.drDraw(layer, 'layer', value);
				}
				await this.eventThrow(undefined, undefined, 'fbChanged');
			}

			drCreate(width, height) {
				if(typeof width !== 'number' || typeof height !== 'number') {
					throw new TypeError('Incorrect dimensions');
				}

				let layer = document.createElement('canvas');

				layer.width = width;
				layer.height = height;
				layer.context2d = layer.getContext('2d');
				layer.context2d.imageSmoothingQuality = 'high';

				return layer;
			}

			async drCreateAsync(width, height) {
				if(typeof width !== 'number' || typeof height !== 'number') {
					throw new TypeError('Incorrect dimensions');
				}

				let layer = new OffscreenCanvas(width, height);

				layer.context2d = layer.getContext('2d');
				layer.context2d.imageSmoothingQuality = 'high';

				return layer;
			}

			async drOpen(data, type) {
				let base64 = /^data:(.+);base64,(.+)/i,
					URL = /^([a-z]+:\/\/)?[a-z0-9/?#. -]+$/gi;

				if(!data instanceof Buffer && !base64.test(data) && !URL.test(data)) {
					throw new TypeError('Incorrect data');
				}

				if(data instanceof Buffer) {
					type = type ?? this.fsType(data);
					data = data.toString('base64');
				}
				if(base64.test(data)) {
					type = type ?? data.match(base64)[1]
					data = data.match(base64)[2]
				}

				let image = new Image(),
					source = !URL.test(data) ? 'data:'+type+';base64,'+data : data;

				await new Promise(resolve => {
					image.onload = () => resolve();
					image.src = source;
				});

				let layer = this.drCreate(image.naturalWidth, image.naturalHeight);

				layer.context2d.drawImage(image, 0, 0);

				return layer;
			}

			drClose(data) {
				let regex = /^data:image\/(.+);base64,/gi;

				if(!data instanceof HTMLCanvasElement && !regex.test(data)) {
					throw new TypeError('Incorrect data');
				}

				if(data instanceof HTMLCanvasElement) {
					data = Buffer.from(data.toDataURL('png'));
				} else {
					data = Buffer.from(data.replace(regex, ''), 'base64');
				}

				return data;
			}

			drColor(red, green, blue, alpha = 1) {
				red = typeof red === 'string' ? red+'%': red;
				green = typeof green === 'string' ? green+'%': green;
				blue = typeof blue === 'string' ? blue+'%': blue;
				alpha = typeof alpha === 'string' ? Number(alpha)/100 : alpha;

				return `rgba(${ red }, ${ green }, ${ blue }, ${ alpha })`;
			}

			drDraw(layer, type, ...arguments_) {
				let context = layer.context2d;

				return {
					rectangle: (color, x, y, width, height) => {
						context.fillStyle = color;
						context.fillRect(x, y, width, height);
					},
					gradient: (colors, x, y, width, height, fromX, fromY, toX, toY) => {
						let gradient = context.createLinearGradient(x+fromX, y+fromY, x+toX, y+toY);

						for(let v of colors) {
							let position = v[0],
								color = v[1]

							if(typeof position == 'number' && position >= 0 && position <= 1) {
								gradient.addColorStop(position, color);
							}
						}

						context.fillStyle = gradient;
						context.fillRect(x, y, width, height);
					},
					layer: (layer_, x, y, width, height, angle) => {
						let context_ = layer_.context2d;

						if(typeof width == 'string') {
							width = parseInt(width)/100*layer.width;
						}
						if(typeof height == 'string') {
							height = parseInt(height)/100*layer.height;
						}

						if(typeof angle !== 'number') {
							context.imageSmoothingEnabled = !!(width || height);
							context.drawImage(layer_, x ?? 0, y ?? 0, width ?? layer_.width, height ?? layer_.height);
						} else {
							angle = angle*Math.PI/180;

							context.imageSmoothingEnabled = !Math.isEven(angle/90);
							context.translate(x, y);
							context.rotate(angle);
							context.drawImage(layer_, -layer_.width/2, -layer_.height/2);
							context.rotate(-angle);
							context.translate(-x, -y);
						}
					},
					text: (value, { x = 0, y = 0, color = this.colors.black, size = 16, weight = 'regular', style = 'regular' }) => {
						context.font = size+'px Arial';
						context.textBaseline = 'top';
						context.fillStyle = color;
						context.fillText(value, x, y);
					}
				}[type](...arguments_);
			}

			drClip(layer, x, y, width, height) {
				let layer_ = this.drCreate(width, height),
					context = layer.context2d,
					context_ = layer_.context2d;

				context_.putImageData(context.getImageData(x, y, width, height), 0, 0);

				return layer_;
			}

			drBlur(layer, amount, sharp, apply, layer_, x, y, ...arguments_) {
				if(typeof amount !== 'number')	throw new TypeError('Incorrect amount');
				if(amount < 0)					throw new RangeError('Incorrect amount');

				let layer__ = this.drCreate(!sharp ? layer.width+amount*2 : layer.width, !sharp ? layer.height+amount*2 : layer.height);

				layer__.context2d.filter = 'blur('+amount+'px)';

				if(!sharp) {
					this.drDraw(layer__, 'layer', this.drMask(layer, layer_, false, x, y, ...arguments_), amount, amount);
				} else {
					this.drDraw(layer__, 'layer', layer);
					this.drMask(layer__, layer_, true, x, y);
				}

				layer__.context2d.filter = 'none';

				if(!apply) {
					return layer__;
				} else {
					this.drDraw(layer, 'layer', layer__, !sharp ? -amount : 0, !sharp ? -amount : 0);
				}
			}

			/**
			 * Переносит часть слоя в другое место.
			 *
			 * @param {HTMLCanvasElement}	layer	Исходный слой.
			 * @param {'cut'|'copy'}		type	Тип переноса: вырезка или копирование.
			 * @param {number}				x		Исходное положение X.
			 * @param {number}				y		Исходное положение Y.
			 * @param {number}				width	Ширина области.
			 * @param {number}				height	Высота области.
			 * @param {?HTMLCanvasElement}	layer_	Конечный слой. Если не указан, используется исходный.
			 * @param {number}				x_		Конечное положение X.
			 * @param {number}				y_		Конечное положение Y.
			 */
			drMove(layer, type, x = 0, y = 0, width, height, layer_, x_ = 0, y_ = 0) {
				if(!['cut', 'copy'].includes(type) || [
					typeof x,
					typeof y,
					typeof width,
					typeof height,
					typeof x_,
					typeof y_
				].some(v => v !== 'number')) {
					throw new RangeError('Incorrect type');
				}

				let context = layer.context2d,
					data = context.getImageData(x, y, width, height);

				if(type === 'cut') {
					this.drClear(layer, x, y, width, height);
				}
				if(!layer_ instanceof HTMLCanvasElement) {
					context.putImageData(data, x_, y_);
				} else {
					layer_.context2d.putImageData(data, x_, y_);
				}
			}

			drMask(layer, layer_, apply = true, ...arguments_) {
				let layer__ = this.drCreate(layer.width, layer.height);

				this.drDraw(layer__, 'layer', layer_, ...arguments_);

				layer__.context2d.globalCompositeOperation = 'source-in';

				this.drDraw(layer__, 'layer', layer);

				layer__.context2d.globalCompositeOperation = 'source-over';

				if(apply) {
					let context = layer.context2d,
						filters = context.filter;

					context.filter = 'none';

					this.drClear(layer);
					this.drDraw(layer, 'layer', layer__);

					context.filter = filters;
				} else {
					return layer__;
				}
			}

			drClear(layer, x, y, width, height) {
				if(!(x && y && width && height)) {
					x =
					y = 0;
					width = layer.width;
					height = layer.height;
				} else
				if([
					typeof x,
					typeof y,
					typeof width,
					typeof height
				].some(v => v !== 'number')) {
					return;
				}

				layer.context2d.clearRect(x, y, width, height);
			}

			drIterate(layer, function_) {
				let width = layer.width,
					height = layer.height,
					context = layer.context2d,
					data = context.getImageData(0, 0, width, height),
					pixels = data.data;

				for(let y = 0; y < height; ++y) {
					for(let x = 0; x < width; ++x) {
						let i = (y*width+x)*4;

						function_(new Proxy(pixels, {
							get: (target, key) => {
								return {
									x: x,
									y: y,
									red: target[i],
									green: target[i+1],
									blue: target[i+2],
									alpha: target[i+3]
								}[key]
							},
							set: (target, key, value) => {
								return {
									red: () => { target[i] = value; return true; },
									green: () => { target[i+1] = value; return true; },
									blue: () => { target[i+2] = value; return true; },
									alpha: () => { target[i+3] = value; return true; }
								}[key]();
							}
						}));
					}
				}

				context.putImageData(data, 0, 0);
			}

			async eventThrow(processID, processID_, title, ...arguments_) {
				if(processID && this.eventsReserved.includes(title)) {
					throw new RangeError(`Processes aren't allowed to throw reserved events`);
				}
				if(processID && processID_ && processID !== processID_) {
					let process = this.processes.find(v => v.ID === processID),
						group = (await this.fsReadPreferences(undefined, 'Global')).Users.find(v => v.Login === process.user)?.Group;

					if(group > 0) {
						throw new RangeError('Non-root processes allowed to throw events process-specifically to themselves only');
					}
				}

				for(let catcher of this.catchers.filter(v => (processID_ ? v.processID === processID_ : true) && v.title === title)) {
					try {
						catcher.function(...arguments_);
					} catch(error) {
						error.fileName = this.processes.find(v => v.ID === catcher.processID)?.path;
						this.kdInfo(`
							eventThrow@${ catcher.processID }: Catcher failed to execute its function:
							    Process ID: ${ processID_ ?? 'Not set' }
							    Title: "${ title }"
						`, error.stack);
					}
				}
			}

			eventChannelCreate(processID) {
				let ID = this.channels.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				this.channels.push({
					ID: ID,
					processID: processID
				});
				this.kdInfo(`eventChannelCreate${ processID ? '@'+processID : '' }: Object ${ ID } created`);

				return ID;
			}

			eventChannelDestroy(processID, channelID) {}

			/**
			 * Создаёт отловщик событий и возвращает его идентификатор.
			 *
			 * @param	{?number}	processID	Идентификатор процесса.
			 * @param	{string}	title		Название события.
			 * @param	{Function}	function_	Функция отловщика.
			 * @returns	{number}
			 */
			eventCatcherCreate(processID, title, function_) {
				if(typeof title !== 'string')		throw new TypeError('Incorrect title');
				if(typeof function_ !== 'function')	throw new TypeError('Incorrect function');

				let ID = this.catchers.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				this.catchers.push({
					ID: ID,
					processID: processID,
					title: title,
					function: function_
				});
				this.kdInfo(`
					eventCatcherCreate${ processID ? '@'+processID : '' }: Object created:
					    ID: ${ ID }
					    Title: "${ title }"
				`);

				return ID;
			}

			/**
			 * Уничтожает отловщик событий.
			 *
			 * @param {?number}	processID Идентификатор процесса.
			 * @param {number}	catcherID Идентификатор отловщика.
			 */
			eventCatcherDestroy(processID, catcherID) {
				let catcher = this.catchers.find(v => v.ID === catcherID);

				if(!catcher) {
					if(this.verbose) {
						this.kdInfo(`eventCatcherDestroy${ processID ? '@'+processID : '' }: Unable to find object`);
					}

					return;
				}
				if(processID && processID !== catcher.processID) {
					throw new Error(`Processes aren't allowed to destroy not owned objects`);
				}

				this.catchers = this.catchers.filter(v => v !== catcher);
				this.kdInfo(`eventCatcherDestroy${ processID ? '@'+processID : '' }: Object ${ catcher.ID } destroyed`);
			}

			/**
			 * Создаёт таймер и возвращает его идентификатор.
			 *
			 * @param	{?number}	processID	Идентификатор процесса.
			 * @param	{boolean}	repeat		Бесконечное повторение таймера.
			 * @param	{number}	delay		Время задержки.
			 * @param	{Function}	function_	Функция таймера.
			 * @param	{?*}		arguments_	Параметры, передаваемые в функцию таймера.
			 * @returns	{number}
			 */
			timerCreate(processID, repeat, delay, function_, ...arguments_) {
				if(typeof repeat !== 'boolean')		throw new TypeError('Incorrect repeat');
				if(typeof delay !== 'number')		throw new TypeError('Incorrect delay');
				if(typeof function_ !== 'function')	throw new TypeError('Incorrect function');

				let ID = this.timers.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1,
					timer;

				if(!repeat) {
					timer = sbSetTimeout(() => {
						function_(...arguments_);
						this.timerDestroy(processID, ID);
					}, delay);
				} else {
					timer = sbSetInterval(function_, delay, ...arguments_);
				}
				this.timers.push({
					ID: ID,
					processID: processID,
					repeat: repeat,
					timer: timer
				});
				this.kdInfo(`
					timerCreate${ processID ? '@'+processID : '' }: Object created:
					    ID: ${ ID }
					    Repeat: ${ repeat ? 'Yes' : 'No' }
				`);

				return ID;
			}

			/**
			 * Уничтожает таймер.
			 *
			 * @param {?number}	processID	Идентификатор процесса.
			 * @param {number}	timerID		Идентификатор таймера.
			 */
			timerDestroy(processID, timerID) {
				let timer = this.timers.find(v => v.ID === timerID);

				if(!timer) {
					if(this.verbose) {
						this.kdInfo(`timerDestroy${ processID ? '@'+processID : '' }: Unable to find object`);
					}

					return;
				}
				if(processID && processID !== timer.processID) {
					throw new Error(`Processes aren't allowed to destroy not owned objects`);
				}

				if(!timer.repeat) {
					sbClearTimeout(timer.timer);
				} else {
					sbClearInterval(timer.timer);
				}
				this.timers = this.timers.filter(v => v !== timer);
				this.kdInfo(`timerDestroy${ processID ? '@'+processID : '' }: Object ${ timer.ID } destroyed`);
			}

			/**
			 * Создаёт общее окружение для передачи информации между процессами и возвращает его идентификатор.
			 *
			 * @param	{?number} processID	Идентификатор процесса.
			 * @param	{'r'|'u'} access	Уровень доступа: чтение или чтение/запись.
			 * @param	{?string} title		Название.
			 * @returns	{number}
			 */
			seCreate(processID, access, title) {
				if(typeof access !== 'string')						throw new TypeError('Incorrect access');
				if(typeof title !== 'string')						throw new TypeError('Incorrect title');
				if(!['r', 'u'].includes(access))					throw new RangeError('Incorrect access');
				if(title && this.se.find(v => v.title === title))	throw new RangeError(`Object with same title already exists`);

				let ID = this.se.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1;

				this.se.push({
					ID: ID,
					processID: processID,
					access: access,
					title: title,
					environment: {}
				});
				this.kdInfo(`
					seCreate${ processID ? '@'+processID : '' }: Object created:
					    ID: ${ ID }
					    Access: ${ access === 'r' ? 'Read' : 'Read-Write' }
					    Title: ${ title ? '"'+title+'"' : 'Not set' }
				`);

				return ID;
			}

			/**
			 * Возвращает список идентификаторов существующих общих окружений, созданных процессом,
			 * чей идентфикатор указан (или всех, если последнего нет).
			 *
			 * @param	{?number} processID Идентификатор процесса.
			 * @returns	{number[]}
			 */
			seList(processID) {
				return this.se.filter(v => (!processID || v.processID === processID)).map(v => v.ID);
			}

			seInfo(processID, seSearch) {
				if(!['number', 'string'].includes(typeof seSearch)) {
					throw new TypeError('Incorrect search');
				}

				let se = this.se.find(v => v.ID === seSearch || v.title === seSearch);

				if(!se) {
					if(this.verbose) {
						this.kdInfo(`seInfo${ processID ? '@'+processID : '' }: Unable to find object`);
					}

					return;
				}

				let validator = {
					get: (target, key) => {
						if(this.se.find(v => v === se)) {
							if(processID && processID !== se.processID && se.access === 'r' && typeof target[key] === 'object') {
								return new Proxy(target[key], validator);
							}

							return target[key]
						}
					},
					set: (target, key, value) => {
						if(this.se.find(v => v === se)) {
							if(processID && processID !== se.processID && se.access === 'r') {
								return;
							}

							target[key] = value;

							return true;
						}
					}
				}

				return {
					ID: se.ID,
					processID: se.processID,
					access: se.access,
					title: se.title,
					environment: new Proxy(se.environment, validator)
				}
			}

			seDestroy(processID, seSearch) {
				if(!['number', 'string'].includes(typeof seSearch)) {
					throw new TypeError('Incorrect search');
				}

				let se = this.se.find(v => v.ID === seSearch || v.title === seSearch);

				if(!se) {
					if(this.verbose) {
						this.kdInfo(`seDestroy${ processID ? '@'+processID : '' }: Unable to find object`);
					}

					return;
				}
				if(processID && processID !== se.processID) {
					throw new Error(`Processes aren't allowed to destroy not owned objects`);
				}

				this.se = this.se.filter(v => v !== se);
				this.kdInfo(`seDestroy${ processID ? '@'+processID : '' }: Object ${ se.ID } destroyed`);
			}

			async dlLoad(processID, path) {
				if(processID && typeof processID !== 'number')	throw new TypeError('Incorrect process ID');
				if(typeof path !== 'string')					throw new TypeError('Incorrect path');

				let process = this.processes.find(v => v.ID === processID),
					dl = this.dl.find(v => v.path === path);

				if(dl?.processIDs.includes(processID)) {
					throw new Error('Library already attached to process');
				}

				if(!dl) {
					if(!await this.fsExists(path)) {
						throw new Error('Unable to access requested library');
					}

					dl = {
						ID: this.dl.reduce((a, b) => b.ID > a ? b.ID : a, -1)+1,
						processIDs: [],
						path: path,
						title: path.split('/').pop().replace(`'`, '_'),
						code: undefined
					}

					try {
						dl.code = this.codePrepare(`
							_environment['_dl_${ dl.title }'] = async (_title, _path) => {
								${ await this.fsRead(path) }
							}
						`);
					} catch(error) {
						error.message = 'Unable to parse requested library';

						throw error;
					}

					this.dl.push(dl);
					if(this.verbose) {
						this.kdInfo(`
							dlLoad@${ processID }: Object created:
								ID: ${ dl.ID }
								Path: ${ path }
								Title: "${ dl.title }"
						`);
					}
				}

				dl.processIDs.push(processID);

				return new Promise((resolve, reject) => {
					let a = (error) => {
						if(Object.isObject(error)) {
							error.fileName = process.path;
						}
						this.kdInfo(`dlLoad@${ processID }: Unable to execute requested library: ${ error.message ?? error }`, error.stack);
						this.dlUnload(processID, dl.ID);

						reject(error);
					}

					try {
						this.sbExecute(dl.code, process.environment, dl.title);
					} catch(error) {
						a(error);
					}
					process.environment['_dl_'+dl.title](dl.title, path).then(v => {
						delete process.environment['_dl_'+dl.title]
						resolve(dl.ID);
					}, error => {
						a(error);
					});
				});
			}

			dlUnload(processID, dlID) {
				if(!processID || dlID == null) {
					throw new Error('One or several arguments missing');
				}

				let dl = this.dl.find(v => v.ID === dlID);

				if(!dl) {
					if(this.verbose) {
						this.kdInfo(`dlUnload${ processID }: Unable to find object`);
					}

					return;
				}
				if(!dl.processIDs.includes(processID)) {
					if(this.verbose) {
						this.kdInfo(`dlUnload@${ processID }: Process isn't attached`);
					}

					return;
				}

				dl.processIDs = dl.processIDs.filter(v => v !== processID);
				if(dl.processIDs.length === 0) {
					this.dl = this.dl.filter(v => v !== dl);
				}
				if(this.verbose) {
					this.kdInfo(`dlUnload@${ processID }: Object ${ dl.ID } destroyed`);
				}
			}

			/**
			 * Интерфейс для Dynamic Linker'а. Поддерживает как обычные библиотеки, так и framework'и.
			 *
			 * С помощью переменных окружения `_dlLibrariesPaths` и `_dlFrameworksPaths` можно контролировать
			 * пути поиска (строка с разделением через `;`). ~~Переменная `_dlFrameworksPaths` изменяется автоматически
			 * в зависимости от подключаемых framework'ов.~~
			 *
			 * _Этот метод является частью Objective-Root._
			 *
			 * @param {Object}	process	Объект процесса.
			 * @param {string}	title	Название библиотеки или framework'а в формате `library` или `<framework>`.
			 */
			async dlImport(process, title) {
				if(!Object.isObject(process))					throw new TypeError('Incorrect process');
				if(typeof title !== 'string')					throw new TypeError('Incorrect title');
				if(!this.processes.find(v => v === process))	throw new RangeError('Incorrect process');
				if(title.length === 0 || title === '<>')		throw new RangeError('Incorrect title');

				let framework = /^<.+>$/.test(title),
					paths = process.environment['_dl'+(framework ? 'Frameworks' : 'Libraries')+'Paths']
						.split(';')
						.filter(v => v.length > 0)
						.map(v => this.urlPathNormalize(v)
							.replace(/^~\//, '/Users/'+process.user+'/')
							.replace(/\/$/, '')
						),
					path;

				title = framework ? title.substring(1, title.length-1) : title;

				for(path of paths) {
					path = framework ? path+'/'+title+'.framework/Contents/Executables/'+title : path+'/'+title+'.dylib';

					if(await this.fsExists(path)) {
						break;
					} else {
						path = undefined;
					}
				}

				if(!path) {
					throw new Error(`Unable to find requested ${ title } ${ framework ? 'framework' : 'library' }`);
				}

				return new Promise((resolve, reject) => {
					this.dlLoad(process.ID, path).then(async () => {
						this.kdInfo(`dlImport: Successfully imported ${ title } ${ framework ? 'framework' : 'library' } into process ${ process.ID }`);
						await this.eventThrow(undefined, process.ID, 'libraryListChanged', { event: 'added', title: title, path: path });

						resolve();
					}, error => {
						if(error.message?.includes('Library already attached')) {
							return resolve();
						}

						reject(`Failed to import requested ${ title } ${ framework ? 'framework' : 'library' }${ error.message ? ': '+error.message : '' }`);
					});
				});
			}

			/**
			 * Регистрирует устройство-терминал с названием вида `term*`.
			 *
			 * @param	{number} processID Идентификатор процесса.
			 * @returns	{number}
			 */
			async terminalRegister(processID) {
				let process = this.processes.find(v => v.ID === processID),
					terminals = this.devices.filter(v => /^term[0-9]+$/.test(v.title)),
					ID = terminals.length;

				await this.deviceRegister('c', 'term'+ID, undefined, {
					read: this.terminalRead,
					write: this.terminalWrite,
					control: this.terminalControl
				}, {
					parentID: process?.terminalID ?? 0,
					mode: 'text',
					current: !terminals.some(v => v.data.current),
				});
				await this.eventThrow(undefined, undefined, 'terminalListChanged', { event: 'added', value: ID });

				return ID;
			}

			async terminalCreate(process) {
				let ID = this.terminals.reduce((a, b) => b.ID > a ? b.ID : a, 0)+1;

				this.terminals.push({
					ID: ID,
					parentID: process?.terminalID ?? 0,
					mode: 'text',
					current: !this.terminals.some(v => v.current),
					strings: []
				});
				await this.eventThrow(undefined, undefined, 'terminalListChanged', { event: 'added', value: ID });

				return ID;
			}

			get terminalCurrent() {
				return this.terminals.find(v => v.current)?.ID;
			}

			set terminalCurrent(terminalID) {
				if(this.terminals.find(v => v.ID === terminalID)) {
					for(let v of this.terminals) {
						v.current = v.ID === terminalID;
					}
				}
			}

			terminalInput(processID, value) {
				this.eventThrow(undefined, undefined, 'terminalChanged', { event: 'input', processID: processID, value: value });
			}

			async terminalOutput(process, value, terminalID) {
				terminalID ??= process?.terminalID;

				let terminal = this.terminals.find(v => v.ID === terminalID);

				if(!terminal) {
					throw new RangeError('Unable to find terminal');
				}
				if(process && process.terminalID !== terminalID && process.terminalID !== terminal.parentID) {
					throw new Error(`Processes aren't allowed to output into non-parent and not owned terminals`);
				}

				let ID = terminal.strings.length > 0 ? Math.max(...terminal.strings.map(v => v.ID))+1 : 1,
					string = {
						ID: ID,
						timestamp: Date.now(),
						processID: process?.ID || undefined,
						value: value
					}

				terminal.strings.push(string);
				await this.eventThrow(undefined, undefined, 'terminalChanged', {
					event: 'output',
					terminalID: terminal.ID,
					stringID: ID,
					processID: process?.ID,
					value: value
				});

				return new Proxy(string, {
				//	get: (target, key) => {
				//		return key !== 'ID' ? target[key] : undefined;
				//	},
					set: async (target, key, value) => {
						if(key === 'value') {
							target[key] = value;
							await this.eventThrow(undefined, undefined, 'terminalChanged', {
								event: 'output',
								terminalID: terminal.ID,
								stringID: ID,
								processID: process?.ID,
								value: value
							});

							return true;
						}
					}
				});
			}

			terminalMode(process, value, terminalID) {
				terminalID ??= process?.terminalID;

				let terminal = this.terminals.find(v => v.ID === terminalID);

				if(!['text', 'graphics'].includes(value)) {
					throw new Error('Incorrect mode');
				}
				if(!terminal) {
					if(this.verbose) {
						this.kdInfo(`terminalMode${ process ? '@'+process.ID : '' }: Unable to find terminal`);
					}

					return;
				}
				if(terminal.parentID) {
					throw new Error(`Child terminals shouldn't have changeable mode`);
				}
				if(process && process.terminalID !== terminalID) {
					throw new Error(`Processes aren't allowed to set mode of non-parent terminals`);
				}

				terminal.mode = value;
			}

			terminalDestroy(process, terminalID) {
				let terminal = this.terminals.find(v => v.ID === terminalID);

				if(!terminal) {
					if(this.verbose) {
						this.kdInfo(`terminalDestroy${ process ? '@'+process.ID : '' }: Unable to find terminal`);
					}

					return;
				}
				if(process && process.terminalID !== terminal.parentID) {
					throw new Error(`Processes aren't allowed to destroy not owned terminals`);
				}

				for(let v of this.processes.filter(v => v.terminalID === terminal.ID)) {
					this.processKill(v.ID);
				}
				this.terminals = this.terminals.filter(v => v !== terminal);
				this.kdInfo(`terminalDestroy: Terminal ${ terminal.ID } destroyed`);
				this.eventThrow(undefined, undefined, 'terminalListChanged', { event: 'removed', value: terminal.ID });
			}

			/**
			 * Подготавливает окружение, (частично) изолируя его от остальной среды.
			 *
			 * @param {Object} environment Сырое окружение.
			 * @returns {Context}
			 */
			sbCreate(environment) {
				return require('vm').createContext(environment);
			}

			/**
			 * Запускает код в окружении.
			 *
			 * @param {string}	code		Код.
			 * @param {Context}	environment	Окружение.
			 * @param {?string}	title		Название окружения, видимое при отладке.
			 */
			sbExecute(code, environment, title) {
				return require('vm').runInContext(code, environment, {
					filename: title?.split('/').pop(),
					timeout: 60000
				});
			}

			processCall(process, title, ...arguments_) {
				let methods = {
					version: (a) => this.version[a],
					uptime: () => this.uptime,
					screen: () => this.screen,
					log: (...a) => this.kdInfo(process.path.split('/').pop()+': ', ...a),
					createDir: (a) => this.fsCreateDirectory(a),
					createNode: (...a) => this.fsCreateNode(...a),
					remove: (a) => this.fsDestroy(a),
					exists: (a) => this.fsExists(a),
					existsDir: (a) => this.fsExistsDirectory(a),
					read: (a) => this.fsRead(a),
					readDir: (a) => this.fsReadDirectory(a),
					readPref: (a) => this.fsReadPreferences(process, a),
					write: (...a) => this.fsWrite(...a),
					writePref: (...a) => this.fsWritePreferences(process, ...a),
					fbWrite: (a) => this.fbWrite(process, a),
					drCreate: (...a) => this.drCreate(...a),
					drOpen: (...a) => this.drOpen(...a),
					drColor: (...a) => this.drColor(...a),
					drDraw: (...a) => this.drDraw(...a),
					drClip: (...a) => this.drClip(...a),
					drBlur: (...a) => this.drBlur(...a),
					drMove: (...a) => this.drMove(...a),
					drMask: (...a) => this.drMask(...a),
					drClear: (...a) => this.drClear(...a),
					drIterate: (...a) => this.drIterate(...a),
					drClose: (a) => this.drClose(a),
					throw: (...a) => this.eventThrow(process.ID, ...a),
					catcherCreate: (...a) => this.eventCatcherCreate(process.ID, ...a),
					catcherDestroy: (a) => this.eventCatcherDestroy(process.ID, a),
					timerCreate: (...a) => this.timerCreate(process.ID, ...a),
					timerDestroy: (a) => this.timerDestroy(process.ID, a),
					seCreate: (...a) => this.seCreate(process.ID, ...a),
					seList: (a) => this.seList(a ?? process.ID),
					seInfo: (a) => this.seInfo(process.ID, a),
					seDestroy: (a) => this.seDestroy(process.ID, a),
					exec: (...a) => this.processExecute(process.terminalID, process.ID, ...a),
					list: () => this.processList(),
					info: (a) => this.processInfo(a ?? process.ID),
				//	fork: (a) => this.processFork(process.ID, a),
					kill: (a) => this.processKill(a ?? process.ID),
					import: (...a) => this.dlImport(process, ...a),
					protected: (...a) => this.classProtected(process.ID, ...a),
					system: () => this.system(),
					relaunch: () => this.environmentRelaunch(process),
					quit: () => this.environmentQuit(process)
				}

				if(!methods[title]) {
					throw new RangeError('Incorrect title');
				}

				return methods[title](...arguments_);
			}

			/**
			 * Запускает процесс.
			 *
			 * @param	{number}	terminalID	Идентификатор терминала.
			 * @param	{number}	processID	Идентификатор родительского процесса.
			 * @param	{string}	login		Логин пользователя.
			 * @param	{string}	password	Пароль пользователя.
			 * @param	{string}	path		Абсолютный путь к исполняемому файлу.
			 * @param	{string[]}	arguments_	Параметры запуска, передаваемые в точку вхождения.
			 * @returns	{?Object}				Информация о процессе.
			 */
			async processExecute(terminalID, processID, login, password, path, ...arguments_) {
				let user =
						login != null && password != null ? (await this.fsReadPreferences(undefined, 'Global')).Users.find(v => v.Login === login && v.Password === password).Login :
						processID ? this.processes.find(v => v.ID === processID).user : undefined,
					executable = await this.fsRead(path);

				if(terminalID != null && !this.terminals.find(v => v.ID === terminalID)) {
					throw new Error('Incorrect terminal');
				}
				if(terminalID == null) {
					terminalID = await this.terminalCreate();
				}
				if(!user) {
					throw new Error('Incorrect authorization');
				}
				if(!executable) {
					throw new Error('Unable to access executable');
				}

				let process = {
					ID: this.processes.reduce((a, b) => b.ID > a ? b.ID : a, 0)+1,
					parentID: processID ?? 0,
					terminalID: terminalID,
					user: user,
					path: path,
					arguments: arguments_.filter(v => typeof v === 'string'),
					environment: undefined
				}

				process.environment = this.sbCreate(new Proxy({
					_dlLibrariesPaths: '~/lib;/usr/lib;/lib',
					_dlFrameworksPaths: '~/Library/Frameworks;/Library/Frameworks;/Environment/Library/Frameworks',
					_call: (...a) => this.processCall(process, ...a),
					_import: (...a) => this.processCall(process, 'import', ...a),
					_protected: (...a) => this.processCall(process, 'protected', ...a)
				}, {
					get: (target, key) => {
						if(key === '_path')								return process.path;
						if(key === '_arguments')						return [...process.arguments]
						if(['_environment', 'window'].includes(key))	return target;
						if(key === 'require')							return;

						return target[key] ?? this.environment[key]
					}
				}));

				this.processes.push(process);
				this.kdInfo(`
					processExecute${ processID ? '@'+processID : '' }: Process started:
					    ID: ${ process.ID }
					    Parent ID: ${ process.parentID }
					    Terminal ID: ${ process.terminalID }
					    User: ${ process.user }
					    Path: ${ process.path }
				`);
				await this.eventThrow(undefined, undefined, 'processListChanged', { event: 'added', value: process.ID });

				return new Promise((resolve, reject) => {
					let a = (error) => {
						if(Object.isObject(error)) {
							error.fileName = process.path;
						}
						this.kdInfo(`processExecute${ processID ? '@'+processID : '' }: Process ${ process.ID } failed: ${ error.message ?? error }:`, error.stack);
						this.processKill(process.ID, true);
						reject(error);
					}

					try {
						this.sbExecute(this.codePrepare(`
							var _executable = async () => {
								${ executable }
							}
						`), process.environment, process.path);
					} catch(error) {
						a(error);
					}
					process.environment._executable().then(value => {
						if(value.prototype?.constructor.name !== 'Main') {
							a(new Error('Cannot find entry point')); return;
						}
						try {
							process.environment._executable = new value(...process.arguments);
							resolve(this.processInfo(process.ID));
						} catch(error) {
							a(error);
						}
					}, error => {
						a(error);
					});
				});
			}

			/**
			 * Возвращает список идентификаторов запущенных процессов.
			 *
			 * @returns {number[]}
			 */
			processList() {
				return this.processes.map(v => v.ID);
			}

			/**
			 * Возвращает информацию о процессе.
			 *
			 * @param	{number|string} processSearch Идентификатор процесса или путь/конечная часть пути к его исполняемому файлу.
			 * @returns	{Object}
			 */
			processInfo(processSearch) {
				if(!['number', 'string'].includes(typeof processSearch)) {
					throw new TypeError('Incorrect search');
				}

				let infos = [],
					processes = this.processes.filter(v => v.ID === processSearch || typeof processSearch === 'string' && v.path.endsWith(processSearch));

				if(processes.length === 0) {
					if(this.verbose) {
						this.kdInfo(`processInfo: Unable to find processes: `+processSearch);
					}

					return;
				}

				for(let v of processes) {
					infos.push({
						ID: v.ID,
						parentID: v.parentID,
						terminalID: v.terminalID,
						user: v.user,
						path: v.path,
						arguments: [...v.arguments],
					//	memory: Object.sizeOf(v.environment)	// Всё окружение вылетает со свистом
					});
				}

				return typeof processSearch == 'number' ? infos[0] : infos;
			}

		//	processFork(processID) {}

			/**
			 * Завершает указанный процесс, перед этим удаляя все связанные с ним объекты.
			 *
			 * @param {number}		processID	Идентификатор процесса.
			 * @param {?boolean}	quiet		Завершение без отчёта на консоль.
			 */
			processKill(processID, quiet = false) {
				let process = this.processes.find(v => v.ID === processID);

				if(!process) {
					if(this.verbose) {
						this.kdInfo('processKill: Unable to find process '+processID);
					}

					return;
				}

				for(let v of this.catchers.filter(v => v.processID === processID))	this.eventCatcherDestroy(processID, v.ID);
				for(let v of this.timers.filter(v => v.processID === processID))	this.timerDestroy(processID, v.ID);
				for(let v of this.se.filter(v => v.processID === processID))		this.seDestroy(processID, v.ID);
				for(let v of this.dl.filter(v => v.processIDs.includes(processID)))	this.dlUnload(processID, v.ID);
				this.processes = this.processes.filter(v => v !== process);
				if(!quiet) {
					this.kdInfo(`processKill: Process ${ processID } stopped`);
				}
				this.eventThrow(undefined, undefined, 'processListChanged', { event: 'removed', value: processID });
			}

			/**
			 * Интерфейс для обращения к классам и их полям. Поддерживает защищённые и (частично) приватные поля,
			 * друзей, защиту от несанкионированных мутаций, а также прокси-методы для производимых операций.
			 *
			 * Примеры вызовов:
			 * - `classProtected(1, this, Class)` - Вернёт класс.
			 * - `classProtected(1, this, Class, 'field')` - Вернёт поле.
			 * - `classProtected(1, this, Class, 'field', 'set', 'value')` - Запишет в поле.
			 * - `classProtected(1, this, Class, 'field', 'call')` - Вызовет метод.
			 * - `classProtected(1, this, Class, 'field', 'delete')` - Удалит поле.
			 *
			 * Модификаторами доступа полей являются префиксы:
			 * - `__field` - Приватное поле, видимое только родительскому классу.
			 * - `_field` - Защищённое поле, видимое родительскому классу и его детям.
			 * - `field` - Публичное поле, видимое всем.
			 *
			 * Друзья класса определяются в массиве `Class.__friends__`. Несмотря на то, что друзьям доступны любые поля,
			 * некоторые зарезервированы для доступа только из контекста родительского класса:
			 * - `__proto__`
			 * - `__friends__`
			 * - С типом `symbol`
			 *
			 * Под мутациями подразумевается добавление или удаление полей класса, т.е. поведение, свойственное для коллекций,
			 * таких как Object и Array. Любой класс считается коллекцией и имеет публично мутабельные экземпляры,
			 * если он содержит поле `Symbol.collection` со значением `true`.
			 *
			 * Прокси-методы не имеют особых требований к своей реализации, но при их написании стоит знать,
			 * что использование оригинального контекста в целях, обозначаемых текущим методом, однозначно приведёт к рекурсии.
			 *
			 * В качестве примера, их отсутствие аналогично следующим конструкциям:
			 * - `[Symbol.get](self, key) { return self[key] }`
			 * - `[Symbol.set](self, key, value) { self[key] = value; }`
			 * - `[Symbol.call](self, key, ...arguments) { return self[key](...arguments); }`
			 * - `[Symbol.delete](self, key) { delete self[key] }`
			 *
			 * _Этот метод является частью Objective-Root._
			 *
			 * @param {?number}						processID	Идентификатор процесса.
			 * @param {Object}						caller		Обращающийся контекст.
			 * @param {Object}						class_		Класс или объект.
			 * @param {?(string|number|Symbol)}		field		Поле.
			 * @param {'get'|'set'|'call'|'delete'}	type		Тип обращения: получение (по умолчанию), присваивание, вызов и удаление.
			 * @param {?*}							arguments_	Дополнительные аргументы. Используются в случае присваивания (только первый) и вызова.
			 */
			classProtected(processID, caller, class_, field, type = 'get', ...arguments_) {
				if(this.verbose && (!caller || !class_)) {
					this.kdInfo(`classProtected${ processID ? '@'+processID : '' }: No ${ !caller ? `caller's context` : 'class' } set${ field ? ' for: "'+field+'"' : '' }`);
				}
				if(!caller || !class_) {
					return;
				}
				if(field == null) {
					return class_;
				}

				let number = typeof field === 'number',
					symbol = typeof field === 'symbol',
					reserved = ['__proto__', '__friends__'].includes(field) || symbol,
					private_ = !number && !reserved && field.indexOf('__') === 0,
					protected_ = !number && !reserved && !private_ && field.indexOf('_') === 0,
					mutating = type === 'set' && !(field in class_) || type === 'delete' && field in class_,
					environment = this.processes.find(v => v.ID === processID)?.environment,
					global = environment ? Object.isShallowlyEqual(environment, class_) : false,	// Object.isMemberOf(class_, environment)
					equals = Object.isMemberOf(caller, class_) || caller === class_,
					inherits = Object.isKindOf(caller, class_),
					friends = (class_.constructor ?? class_).__friends__ ?? [],
					befriends = !!friends.find(v => Object.isMemberOf(caller, v)),
					mutable = Object.isObject(class_) && (Object.isMemberOf(class_, Object) || Object.isMemberOf(class_, Array) || class_[Symbol.collection] === true);

				if(reserved && !equals) {
					this.kdInfo(`classProtected${ processID ? '@'+processID : '' }: Can't access reserved field: ${ symbol ? field.toString() : field }`); return;
				}
				if(private_ && !global && !equals && !befriends) {
					this.kdInfo(`classProtected${ processID ? '@'+processID : '' }: Can't access private field: ${ field }`); return;
				}
				if(protected_ && !global && !equals && !inherits && !befriends) {
					this.kdInfo(`classProtected${ processID ? '@'+processID : '' }: Can't access protected field: ${ field }`); return;
				}
				if(mutating && !global && !equals && !befriends && !mutable) {
					this.kdInfo(`classProtected${ processID ? '@'+processID : '' }: Can't mutate field: ${ field }`); return;
				}

				let proxied = Symbol[type],
					proxy = new Proxy({}, {
						get: (target, key) => {
							if(key !== proxied) {
								if(type === 'call' && typeof class_[key] === 'function') {
									return class_[key].bind(class_);
								} else {
									return class_[key]
								}
							}
						},
						set: (target, key, value) => {
							class_[key] = value;

							return true;
						},
						deleteProperty: (target, key) => {
							return delete class_[key]
						}
					});

				return {
					'get': () => {
						if(typeof class_[proxied] === 'function') {
							return class_[proxied](proxy, field);
						} else {
							return class_[field]
						}
					},
					'set': () => {
						try {
							if(typeof class_[proxied] === 'function') {
								class_[proxied](proxy, field, arguments_[0]);
							} else {
								class_[field] = arguments_[0]
							}
						} catch(error) {
							if(!error.message.startsWith(`'set' on proxy: trap returned falsish`)) {	// TypeError (какая-то рандомная проблема с Proxy и SE)
								throw error;
							}
						}

						return class_[field]
					},
					'call': () => {
						if(typeof class_[proxied] === 'function') {
							return class_[proxied](proxy, field, ...arguments_);
						} else {
							return class_[field]?.(...arguments_);
						}
					},
					'delete': () => {
						if(typeof class_[proxied] === 'function') {
							return class_[proxied](proxy, field);
						} else {
							return delete class_[field]
						}
					}
				}[type]();
			}

			/**
			 * Подготавливает код для исполнения в процессах.
			 * - Заменяет любое несанкционированное использование `classProtected()` на undefined.
			 * - ~~Заменяет обычные `import` на вызовы `await _import()`.~~
			 * - Добавляет `await` передо всеми вызовами `_import()`.
			 * - Заменяет обычный синтаксис приватных полей на нужный для `classProtected()`.
			 * - Заменяет обычные обращения к полям на проходящие через `classProtected()`.
			 *
			 * _Этот метод является частью Objective-Root._
			 *
			 * @param	{string} code Сырой код.
			 * @returns	{string}
			 */
			codePrepare(code) {
				let recast = require('recast'),
					visit = recast.visit,
					builders = recast.types.builders,
					ast = recast.parse(code, {
						parser: {
							parse(source) {
								return require('flow-parser').parse(source, {
									esproposal_class_instance_fields: true,
									esproposal_class_static_fields: true,
									esproposal_decorators: true,
									esproposal_export_star_as: true,
									esproposal_nullish_coalescing: true,
									esproposal_optional_chaining: true
								});
							}
						}
					});

				visit(ast, {
					visitIdentifier(path) {
					//	let _protected;		===	let undefined;

					//	_protected = *;		===	undefined = *;
					//	* = _protected;		===	* = undefined;

					//	_protected();		===	undefined();

					//	return _protected;	===	return undefined;

					//	{ _protected }	===	{ _protected: undefined }

					//	* = _protected;		===	* = undefined;
					//	#* = _protected;	===	#* = undefined;

						if(path.node.name === '_protected') {
							if(
								['VariableDeclarator', 'AssignmentExpression', 'CallExpression', 'ReturnStatement'].includes(path.parentPath.node.type) ||
								['ObjectProperty', 'ClassProperty', 'ClassPrivateProperty'].includes(path.parentPath.node.type) && path.parentPath.node.value === path.node
							) {
								path.replace(builders.identifier('undefined'));
							}
						}

						this.traverse(path);
					}
				});
				visit(ast, {
					visitAnyTypeAnnotation(path) {
						delete path.node.loc;
						delete path.node.range;
					},
					/*
					visitExpressionStatement(path) {
						this.traverse(path);

						if(path.parentPath.node.type === 'Program' && path.parentPath.node.body.length === 1) {
							path.replace(builders.returnStatement(path.node.expression));
						}
					},
					*/
					/*
					visitImportDeclaration(path) {
						let string = '';

						if(path.node.specifiers.length === 0) {
						//	path.replace(builders.awaitExpression(builders.callExpression(builders.identifier('_import'), [path.node.source])));
							string += `await _import('${ path.node.source.value }')`;
						} else {
							for(let v of path.node.specifiers) {
								string += `await _import('${ path.node.source.value }', '${ v.local.name }')`;
							}
						}

						path.replace(undefined);
						path.insertAfter(string);

						this.traverse(path);
					},
					*/
					visitCallExpression(path) {
						this.traverse(path);

						if(path.node.callee.name === '_import' && path.parentPath.node.type !== 'AwaitExpression') {
							path.replace(builders.awaitExpression(path.node));
						}
					},
					visitNewExpression(path) {
						if(path.node.callee.name === 'Proxy') {
							return false;
						}

						this.traverse(path);
					},
					visitClassPrivateProperty(path) {
					//	#property	===	__property

						path.node.type = 'ClassProperty';
						path.node.key.name = '__'+path.node.key.name;

						this.traverse(path);
					},
					visitPrivateName(path) {
					//	#field	===	__field

						path.node.id.name = '__'+path.node.id.name;
						path.replace(path.node.id);

						this.traverse(path);
					},
					visitMemberExpression(path) {
					//	object.property; ||
					//	object['property']				===	_protected(this, object, 'property');
					//	object[property]				===	_protected(this, object, property);

					//	object.property = ''; ||
					//	object['property'] = '';		===	_protected(this, object, 'property', 'set', '');
					//	object[property] = '';			===	_protected(this, object, property, 'set', '');

					//	object.property(arguments); ||
					//	object['property'](arguments);	===	_protected(this, object, 'property', 'call', arguments);
					//	object[property](arguments);	===	_protected(this, object, property, 'call', arguments);

					//	delete object.property; ||
					//	delete object['property']		===	_protected(this, object, 'property', 'delete');
					//	delete object[property]			===	_protected(this, object, property, 'delete');

						this.traverse(path);

						let node = path.node,
							parentNode = path.parentPath.node,
							object = node.object,
							property = node.property,
							propertyName = property.name || property.value,
							propertyComputed = node.computed,
						//	propertyOptional = node.optional,
						//	set = (parentNode.type === 'AssignmentExpression' || parentNode.type === 'LogicalExpression' && path.parentPath.parentPath.node.type === 'AssignmentExpression') && parentNode.left === node,
							set = parentNode.type === 'AssignmentExpression' && parentNode.left === node,
							call = ['OptionalCallExpression', 'CallExpression'].includes(parentNode.type) && parentNode.callee === node,
							delete_ = parentNode.type === 'UnaryExpression' && parentNode.operator === 'delete';

						if(['Super'].includes(object.type) /*|| parentNode.type == 'ExpressionStatement'*/) {
							return false;
						}

						let callNode = builders.callExpression(builders.identifier('_protected'), [
							builders.thisExpression(),
							object,
							!propertyComputed && property.type === 'Identifier' ? builders.stringLiteral(propertyName) : property,
							...set ? [builders.stringLiteral('set'), parentNode.right] : call ? [builders.stringLiteral('call'), ...parentNode.arguments] : delete_ ? [builders.stringLiteral('delete')] : []
						]);

						if(set || call || delete_) {
							path.parentPath.replace(callNode);

							this.traverse(path.parentPath);
						} else {
							path.replace(callNode);
						}
					}
				});

				code = recast.print(ast).code;

				return code;
			}

			system() {
				let system = require('os');

				system.gpu ??= require('child_process').spawnSync('wmic', ['path', 'win32_VideoController', 'get', 'name']).stdout?.toString().replace('Name ', '').trim();

				return system;
			}

			/**
			 * Перезапускает Окружение.
			 */
			async environmentRelaunch(process) {
				let group = (await this.fsReadPreferences(undefined, 'Global')).Users.find(v => v.Login === process?.user)?.Group;

				if(process && group > 0) {
					console.error(0); return;
				}

			//	chrome.runtime.reload();
				window.location.reload();
			}

			/**
			 * Завершает Окружение.
			 */
			async environmentQuit(process) {
				let group = (await this.fsReadPreferences(undefined, 'Global')).Users.find(v => v.Login === process?.user)?.Group;

				if(process && group > 0) {
					console.error(0); return;
				}

				window.close();
			}

			async __test() {
				$('framebuffer').css('z-index', 2);
				this.verbose = true;
				let e = this.processes[0].environment,
					s = e.CGSWindowServer.shared;

				return s.__test();
			}

			/**
			 * @todo
			 *
			 * Трекер задач:
			 * - [!] Перевести DOM-интерфейс на Canvas.
			 * - [~] Дописать методы FS, UniversalFS и DevicesFS. Разделить deviceID на deviceMajorID и deviceMinorID, использующихся для указания
			 *       идентификатора устройства и его экземпляров соответственно.
			 * - [~] Добавить возможность импорта обычных библиотек. Желательно с динамическим путём поиска.
			 * - [~] Дописать функции асинхронного ввода/вывода.
			 * - [~] Дописать поддержку нескольких курсоров в CGSWindowServer.
			 * - [~] Везде заменить CFArrayOld на CFArray.
			 * - [~] Добавить CFObject в качестве прототипа всем нестатичным классам framework'ов.
			 * - [~] Закрыть возможность вызова функций/методов в чужом контексте через .call() и .bind().
			 * - [~] Закрыть возможность доступа к полям без проверок безопасности напрямую через
			 *       .assign(), .defineProperty(), .defineProperties() и .values().
			 * - [~] Добавить в .eventCatcherCreate() и .eventThrow() возможность ограничения определённым каналом (а не только процессом).
			 * - [~] Добавить .fs* методам таблицу открытых файлов (и внедрить идею файл-дескрипторов - как оказалось,
			 *       по сути своей тех же ID, что и везде).
			 * - [~] Добавить классы-интерфейсы к объектам CGSWindowServer.
			 * - [~] Разобраться с созданием окон в CGSWindowServer (обеспечить отрисовку слоёв окон в .__draw()).
			 * - [~] Добавить возможность смены workspac'ов с анимациями. При переходах фиксированные окна естественно должны оставаться
			 *       на месте, а для этого было бы неплохо продумать наиболее производительный способ. Теоретически, такие окна должны на
			 *       время выпадать из основного потока отрисовки (либо вообще не входить в него), но при этом иметь воможность продолжать
			 *       выглядеть так, как будто они этого не делают. На данный момент для анимации скольжения некоторые окна потребуется
			 *       отрисовывать два раза на двух разных слоях (для каждого workspac'а по одному соответственно). По идее, такое разделение
			 *       workspac'ов должно давать прирост производительности в общих случаях, когда идёт отрисовка только на одном из них,
			 *       потому что не нужно рисовать один большой слой и вырезать из него область, но его проблема в том, что оно становиться
			 *       неудобным в той же анимации скольжения, когда нельзя просто взять и отрисовать один слой окна среди кучи других без
			 *       каких либо модификаций. С другой стороны, мешанина из окон тоже должна контролироваться, и для предотвращения наложения
			 *       workspac'ов каждое окно должно будет ограничиваться маской (иногда, вероятно, двойной; чьё положение придётся менять
			 *       соответственно положению окна), что наверняка также скажется на производительности. Какое из двух зол меньшее -
			 *       не знаю, лично мне кажеться первое, но судя по моим стресс-тестам WindowServer'а в OS X 10.9, принцип отрисовки там
			 *       больше схож со вторым описанием (один единый слой и куча масок), так что с этим ещё предстоит разбираться...
			 * - [~] Добавить в CGLayer поддержку недеструктивной модификации его стиля через свойства .shadow, .transform и т.д.
			 * - [~] Избавиться от некорректного класса LFFrame. Заголовки окон и всё остальное, что не входит в .contentView,
			 *       должно иметь прозрачный фон, а градиент отрисовываться на самом LFWindow, при этом размеры градиента должны
			 *       устанавливаться в момент отрисовки в зависимости от размеров и положения .contentView.
			 * - [~] Добавить проверку типов вовсюда.
			 * - [~] Переписать LFWorkspace так, чтобы он не отвечал за вмещение в себя view'ов. Любые view'ы (в том числе LFMenubar)
			 *       должны отрисовываться посредством LFWindow (CGSWindow).
			 * - [~] Дописать в Dock'е поддержку изображений для нескольких workspac'ов.
			 * - [~] Написать Mission Control (часть Dock) и Notification Center.
			 * - [~] Заменить _import() в классах на import при первой возможности (когда исправят баг в recast).
			 * - [~] Добавить необходимые _import()'ы в классы.
			 * - [~] Доработать (оптимизировать) асинхронность процессов (мультизадачность).
			 * - [?] Добавить проверку необходимости оператора ?. в .codePrepare() (вместо его слепой расстановки вовсюда).
			 * - [?] Законопатить дырку безопасности, связанную с возможностью перезаписи приватных полей классами-наследниками.
			 * - [?] Добавить поддержку разнообразных сигналов. Смысл как у событий, но в отличии от них список относительно
			 *       стандартизирован, а момент уведомления преимущественно перед действиями, а не после.
			 * - [?] Раскомментить и переписать processFork() так, чтобы он соответствовал реализации в Linux (создаётся дочерний процесс
			 *       с окружением и объектами скопированными из родительского).
			 *
			 * Обозначения:
			 * - ! - Важные, текущие задачи.
			 * - ~ - Подзадачи, либо менее важные задачи, к которым стоит перейти при первом удобном случае.
			 * - ? - Задачи с низким приоритетом по причине неясности пути и/или неуверенности в нужде реализации.
			 * - X - Скорее всего отменённые задачи.
			 */
		}().initialize();
	</script>
	<style type="text/css">
		@font-face {
			src: url('/Environment/Library/Fonts/Debug.ttf') format('truetype');
			font-family: 'Debug';
			font-style: normal;
			font-weight: normal;
		}

		body {
			overflow: hidden;

			margin: 0;

			background: rgb(0 0 0);

			cursor: none;
			user-select: none;
		}

		img {
			-webkit-user-drag: none;
		}

		kdb {
			position: absolute;
			z-index: 0;

			width: 100%;
			height: 100%;

			cursor: none;
		}

		kdb[panic] {
			z-index: 2;
		}

		kdb strings {
			display: none;

			position: absolute;

			width: 100%;
			height: 100%;
			overflow-y: scroll;

			color: #ffffff;
			font: 16px Debug;
			line-height: 16px;
			white-space: pre;
		}

		kdb strings::-webkit-scrollbar {
			display: none;
		}

		body[verbose] kdb strings {
			display: block;
		}

		kdb string {
			display: block;
		}

		kdb text {
			background: #000000;
		}

		@property --kdb_panic_background {
			syntax: '<percentage>';
			inherits: true;
			initial-value: 0%;
		}

		kdb panic {
			display: none;

			position: absolute;

			width: 100%;
			height: 100%;

			background: linear-gradient(to bottom,
				rgba(0,0,0,0.25) 0%,
				rgba(0,0,0,0.25) var(--kdb_panic_background),
				rgba(0,0,0,0) var(--kdb_panic_background),
				rgba(0,0,0,0) 100%
			);
		}

		@keyframes kdb_panic {
			0%		{ --kdb_panic_background: 0%; }
			100%	{ --kdb_panic_background: 100%; }
		}

		body:not([verbose]) kdb[panic] panic {
			display: block;

			animation: kdb_panic 1s linear;
			animation-fill-mode: forwards;
		}

		kdb img {
			position: absolute;
			top: 50%;
			left: 50%;

			opacity: 0;
			transform: translate(-50%, -50%);
		}

		@keyframes kdb_panic_img {
			0%		{ opacity: 0; }
			100%	{ opacity: 1; }
		}

		body:not([verbose]) kdb[panic] img {
			animation: kdb_panic_img 1s steps(1);
			animation-fill-mode: forwards;
		}

		wormhole,
		framebuffer,
		framebuffer canvas {
			position: absolute;
			top: 0;
			left: 0;

			-width: 100%;
			-height: 100%;
		}

		framebuffer {
			z-index: 0;	/* 2 */

			pointer-events: none;
		}

		wormhole > *:not([visible]) {
			display: none;
		}

		wormhole div {
			display: block;

			position: absolute;
			top: 64px;
			left: 64px;

			width: 64px;
			height: 64px;

			background: rgba(50%,50%,50%,1);
			border-radius: 16px;
		}
	</style>
</head>
<body>
	<kdb>
		<strings></strings>
		<panic>
			<img src="data:image/png;base64,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">
		</panic>
	</kdb>
	<wormhole>
		<div></div>
	</wormhole>
	<framebuffer></framebuffer>
</body>
</html>